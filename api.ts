/* tslint:disable */
/* eslint-disable */
/**
 * Product Configurator Service
 * ## Introduction  This comprehensive guide will equip you with the knowledge to integrate and leverage our Product Configurator Service in your applications.  ## Quick Start  Get up and running in no time! Follow these steps to kickstart your integration:  1. **Authentication:** Obtain your integration JWT to authenticate your requests. 2. **Client Libraries:** Explore our GitHub repositories to grab client libraries in your preferred programming language. 3. **API Overview:** Familiarize yourself with our RESTful API using the OpenAPI specification.  ## Integration  ### API Overview  Our RESTful API is the gateway to unlocking the full potential of Product Configurator. Check out the detailed [API Reference](/docs/category/configurator) for a granular understanding of each endpoint and request/response format.  ### Client Libraries  To expedite your integration process, we provide client libraries for various programming languages. Find the one that suits your stack in our [GitHub repositories](https://github.com/Gemini-Commerce).  ### Authentication  Security is paramount. Learn how to authenticate your requests using JWT. This ensures a secure and reliable connection between your application and Product Configurator.  ## Configuration Management  ### Configurator Lifecycle  Understand the lifecycle of configurators, from draft to active and deleted. This flexibility allows you to manage configurations at your own pace.  ### Steps and Options  Configure product steps with ease and define options effortlessly. Explore the power of dependencies to create dynamic and intuitive configurations.  ### Matrices  Delve into matricesâ€”your secret weapon. Explore price and weight matrices, and learn how configured steps influence properties and pricing.  ### Price Management  Unleash dynamic pricing with our versatile price matrices. From fixed prices to incremental structures, adapt to diverse pricing models effortlessly.  ## Security  Your data is in safe hands. Discover how Product Configurator ensures security through JWT authentication, safeguarding your sensitive information.  ## Backward Compatibility  Stay ahead of the curve. Learn about our versioning strategy, providing backward compatibility while allowing our service to evolve seamlessly.  ## Developer Support  Have questions? Need assistance? Write to us at [info@gemini-commerce.com](mailto:info@gemini-commerce.com) and we will get back to you.
 *
 * The version of the OpenAPI document: v1
 * Contact: info@gemini-commerce.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ConfigurationConfigurationStep
 */
export interface ConfigurationConfigurationStep {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationConfigurationStep
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationConfigurationStep
     */
    'grn'?: string;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ConfigurationConfigurationStep
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {Array<ConfigurationStepOption>}
     * @memberof ConfigurationConfigurationStep
     */
    'options'?: Array<ConfigurationStepOption>;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationConfigurationStep
     */
    'hasMultipleSelection'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfigurationConfigurator
 */
export interface ConfigurationConfigurator {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationConfigurator
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationConfigurator
     */
    'grn'?: string;
    /**
     * 
     * @type {Array<ProductconfiguratorconfigurationStep>}
     * @memberof ConfigurationConfigurator
     */
    'steps'?: Array<ProductconfiguratorconfigurationStep>;
}
/**
 * 
 * @export
 * @interface ConfigurationGetAvailableConfigurationResponse
 */
export interface ConfigurationGetAvailableConfigurationResponse {
    /**
     * 
     * @type {ConfigurationConfigurator}
     * @memberof ConfigurationGetAvailableConfigurationResponse
     */
    'configurator'?: ConfigurationConfigurator;
    /**
     * 
     * @type {Array<ConfigurationProperty>}
     * @memberof ConfigurationGetAvailableConfigurationResponse
     */
    'matchedProperties'?: Array<ConfigurationProperty>;
    /**
     * 
     * @type {Array<ProductconfiguratorconfigurationSelection>}
     * @memberof ConfigurationGetAvailableConfigurationResponse
     */
    'selections'?: Array<ProductconfiguratorconfigurationSelection>;
}
/**
 * 
 * @export
 * @interface ConfigurationGetConfigurationFromSelectionsResponse
 */
export interface ConfigurationGetConfigurationFromSelectionsResponse {
    /**
     * 
     * @type {Array<ConfigurationConfigurationStep>}
     * @memberof ConfigurationGetConfigurationFromSelectionsResponse
     */
    'steps'?: Array<ConfigurationConfigurationStep>;
    /**
     * 
     * @type {Array<ConfigurationProperty>}
     * @memberof ConfigurationGetConfigurationFromSelectionsResponse
     */
    'matchedProperties'?: Array<ConfigurationProperty>;
}
/**
 * 
 * @export
 * @interface ConfigurationOptionProperty
 */
export interface ConfigurationOptionProperty {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationOptionProperty
     */
    'propertyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationOptionProperty
     */
    'propertyValue'?: string;
    /**
     * 
     * @type {ProductconfiguratorPropertyType}
     * @memberof ConfigurationOptionProperty
     */
    'propertyType'?: ProductconfiguratorPropertyType;
    /**
     * subtract_to_get_variation is a list of values and is used to calculate the variation from the property value.
     * @type {Array<string>}
     * @memberof ConfigurationOptionProperty
     */
    'subtractToGetVariation'?: Array<string>;
}


/**
 * 
 * @export
 * @interface ConfigurationProperty
 */
export interface ConfigurationProperty {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'grn'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigurationProperty
     */
    'optionIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'propertyKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'propertyValue'?: string;
    /**
     * 
     * @type {ProductconfiguratorPropertyType}
     * @memberof ConfigurationProperty
     */
    'propertyType'?: ProductconfiguratorPropertyType;
    /**
     * 
     * @type {ProductconfiguratorPropertyMode}
     * @memberof ConfigurationProperty
     */
    'propertyMode'?: ProductconfiguratorPropertyMode;
}


/**
 * 
 * @export
 * @interface ConfigurationPropertyFilter
 */
export interface ConfigurationPropertyFilter {
    /**
     * 
     * @type {ConfigurationPropertyFilterGenericProperty}
     * @memberof ConfigurationPropertyFilter
     */
    'genericProperty'?: ConfigurationPropertyFilterGenericProperty;
    /**
     * 
     * @type {object}
     * @memberof ConfigurationPropertyFilter
     */
    'priceProperty'?: object;
    /**
     * 
     * @type {object}
     * @memberof ConfigurationPropertyFilter
     */
    'weightProperty'?: object;
}
/**
 * 
 * @export
 * @interface ConfigurationPropertyFilterGenericProperty
 */
export interface ConfigurationPropertyFilterGenericProperty {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPropertyFilterGenericProperty
     */
    'propertyKey'?: string;
}
/**
 * 
 * @export
 * @interface ConfigurationStepOption
 */
export interface ConfigurationStepOption {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationStepOption
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationStepOption
     */
    'grn'?: string;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ConfigurationStepOption
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {OptionSwatch}
     * @memberof ConfigurationStepOption
     */
    'swatch'?: OptionSwatch;
    /**
     * 
     * @type {Array<ConfigurationOptionProperty>}
     * @memberof ConfigurationStepOption
     */
    'optionProperties'?: Array<ConfigurationOptionProperty>;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationStepOption
     */
    'hasQuantity'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfiguratorListResponse
 */
export interface ConfiguratorListResponse {
    /**
     * 
     * @type {Array<ProductconfiguratorconfiguratorEntity>}
     * @memberof ConfiguratorListResponse
     */
    'configurators'?: Array<ProductconfiguratorconfiguratorEntity>;
    /**
     * 
     * @type {string}
     * @memberof ConfiguratorListResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface DependencyCondition
 */
export interface DependencyCondition {
    /**
     * 
     * @type {Array<string>}
     * @memberof DependencyCondition
     */
    'optionIds'?: Array<string>;
    /**
     * 
     * @type {Array<DependencyCondition>}
     * @memberof DependencyCondition
     */
    'conditions'?: Array<DependencyCondition>;
    /**
     * 
     * @type {ProductconfiguratordependencyType}
     * @memberof DependencyCondition
     */
    'type'?: ProductconfiguratordependencyType;
}


/**
 * 
 * @export
 * @interface DependencyListDependenciesResponse
 */
export interface DependencyListDependenciesResponse {
    /**
     * 
     * @type {Array<ProductconfiguratordependencyEntity>}
     * @memberof DependencyListDependenciesResponse
     */
    'dependencies'?: Array<ProductconfiguratordependencyEntity>;
    /**
     * 
     * @type {string}
     * @memberof DependencyListDependenciesResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface GooglerpcStatus
 */
export interface GooglerpcStatus {
    /**
     * 
     * @type {number}
     * @memberof GooglerpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GooglerpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof GooglerpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface ListMatricesRequestFilter
 */
export interface ListMatricesRequestFilter {
    /**
     * 
     * @type {Array<ProductconfiguratorPropertyType>}
     * @memberof ListMatricesRequestFilter
     */
    'propertyType'?: Array<ProductconfiguratorPropertyType>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListMatricesRequestFilter
     */
    'propertyKey'?: Array<string>;
}
/**
 * 
 * @export
 * @interface LocalisationLocalizedText
 */
export interface LocalisationLocalizedText {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LocalisationLocalizedText
     */
    'value'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface MatrixGenericType
 */
export interface MatrixGenericType {
    /**
     * 
     * @type {string}
     * @memberof MatrixGenericType
     */
    'propertyKey'?: string;
}
/**
 * 
 * @export
 * @interface MatrixListMatricesResponse
 */
export interface MatrixListMatricesResponse {
    /**
     * 
     * @type {Array<ProductconfiguratormatrixEntity>}
     * @memberof MatrixListMatricesResponse
     */
    'matrices'?: Array<ProductconfiguratormatrixEntity>;
    /**
     * 
     * @type {string}
     * @memberof MatrixListMatricesResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface MatrixPriceType
 */
export interface MatrixPriceType {
    /**
     * 
     * @type {Array<string>}
     * @memberof MatrixPriceType
     */
    'pricelistGrns'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MatrixWeightType
 */
export interface MatrixWeightType {
    /**
     * 
     * @type {ProductconfiguratorWeightUnit}
     * @memberof MatrixWeightType
     */
    'weightUnit'?: ProductconfiguratorWeightUnit;
}


/**
 * 
 * @export
 * @interface OptionListOptionsResponse
 */
export interface OptionListOptionsResponse {
    /**
     * 
     * @type {Array<ProductconfiguratoroptionEntity>}
     * @memberof OptionListOptionsResponse
     */
    'options'?: Array<ProductconfiguratoroptionEntity>;
    /**
     * 
     * @type {string}
     * @memberof OptionListOptionsResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface OptionSwatch
 */
export interface OptionSwatch {
    /**
     * 
     * @type {string}
     * @memberof OptionSwatch
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionSwatch
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorBulkCreateOptionsRequest
 */
export interface ProductConfiguratorBulkCreateOptionsRequest {
    /**
     * 
     * @type {Array<ProductconfiguratoroptionBulkCreateRequestCreateEntity>}
     * @memberof ProductConfiguratorBulkCreateOptionsRequest
     */
    'options'?: Array<ProductconfiguratoroptionBulkCreateRequestCreateEntity>;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorBulkCreatePropertiesRequest
 */
export interface ProductConfiguratorBulkCreatePropertiesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorBulkCreatePropertiesRequest
     */
    'matrixId'?: string;
    /**
     * 
     * @type {Array<ProductconfiguratorpropertyBulkCreateRequestCreateEntity>}
     * @memberof ProductConfiguratorBulkCreatePropertiesRequest
     */
    'properties'?: Array<ProductconfiguratorpropertyBulkCreateRequestCreateEntity>;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorBulkCreateStepsRequest
 */
export interface ProductConfiguratorBulkCreateStepsRequest {
    /**
     * 
     * @type {Array<ProductconfiguratorstepBulkCreateRequestCreateEntity>}
     * @memberof ProductConfiguratorBulkCreateStepsRequest
     */
    'steps'?: Array<ProductconfiguratorstepBulkCreateRequestCreateEntity>;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorBulkDeleteOptionsRequest
 */
export interface ProductConfiguratorBulkDeleteOptionsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductConfiguratorBulkDeleteOptionsRequest
     */
    'optionIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorBulkDeleteStepsRequest
 */
export interface ProductConfiguratorBulkDeleteStepsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductConfiguratorBulkDeleteStepsRequest
     */
    'stepIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorBulkUpdateOptionsRequest
 */
export interface ProductConfiguratorBulkUpdateOptionsRequest {
    /**
     * 
     * @type {Array<ProductconfiguratoroptionBulkUpdateRequestUpdateEntity>}
     * @memberof ProductConfiguratorBulkUpdateOptionsRequest
     */
    'options'?: Array<ProductconfiguratoroptionBulkUpdateRequestUpdateEntity>;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorBulkUpdatePropertiesRequest
 */
export interface ProductConfiguratorBulkUpdatePropertiesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorBulkUpdatePropertiesRequest
     */
    'matrixId'?: string;
    /**
     * 
     * @type {Array<ProductconfiguratorpropertyBulkUpdateRequestUpdateEntity>}
     * @memberof ProductConfiguratorBulkUpdatePropertiesRequest
     */
    'entities'?: Array<ProductconfiguratorpropertyBulkUpdateRequestUpdateEntity>;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorCopyConfiguratorRequest
 */
export interface ProductConfiguratorCopyConfiguratorRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCopyConfiguratorRequest
     */
    'targetProductId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductConfiguratorCopyConfiguratorRequest
     */
    'copyDependencies'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductConfiguratorCopyConfiguratorRequest
     */
    'copyMatrices'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorCopyOptionRequest
 */
export interface ProductConfiguratorCopyOptionRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCopyOptionRequest
     */
    'targetStepId'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorCopyStepRequest
 */
export interface ProductConfiguratorCopyStepRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCopyStepRequest
     */
    'targetConfiguratorId'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorCreateConfiguratorRequest
 */
export interface ProductConfiguratorCreateConfiguratorRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCreateConfiguratorRequest
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorCreateDependencyRequest
 */
export interface ProductConfiguratorCreateDependencyRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductConfiguratorCreateDependencyRequest
     */
    'optionIds'?: Array<string>;
    /**
     * 
     * @type {DependencyCondition}
     * @memberof ProductConfiguratorCreateDependencyRequest
     */
    'condition'?: DependencyCondition;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorCreateMatrixRequest
 */
export interface ProductConfiguratorCreateMatrixRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCreateMatrixRequest
     */
    'configuratorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCreateMatrixRequest
     */
    'label'?: string;
    /**
     * 
     * @type {MatrixGenericType}
     * @memberof ProductConfiguratorCreateMatrixRequest
     */
    'genericType'?: MatrixGenericType;
    /**
     * 
     * @type {MatrixPriceType}
     * @memberof ProductConfiguratorCreateMatrixRequest
     */
    'priceType'?: MatrixPriceType;
    /**
     * 
     * @type {MatrixWeightType}
     * @memberof ProductConfiguratorCreateMatrixRequest
     */
    'weightType'?: MatrixWeightType;
    /**
     * 
     * @type {Array<ProductconfiguratormatrixStep>}
     * @memberof ProductConfiguratorCreateMatrixRequest
     */
    'steps'?: Array<ProductconfiguratormatrixStep>;
    /**
     * 
     * @type {ProductconfiguratorPropertyMode}
     * @memberof ProductConfiguratorCreateMatrixRequest
     */
    'propertiesMode'?: ProductconfiguratorPropertyMode;
}


/**
 * 
 * @export
 * @interface ProductConfiguratorCreateOptionRequest
 */
export interface ProductConfiguratorCreateOptionRequest {
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductConfiguratorCreateOptionRequest
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCreateOptionRequest
     */
    'position'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCreateOptionRequest
     */
    'externalReferenceId'?: string;
    /**
     * 
     * @type {OptionSwatch}
     * @memberof ProductConfiguratorCreateOptionRequest
     */
    'swatch'?: OptionSwatch;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorCreatePropertyRequest
 */
export interface ProductConfiguratorCreatePropertyRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCreatePropertyRequest
     */
    'matrixId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProductConfiguratorCreatePropertyRequest
     */
    'stepIdToOptionId'?: { [key: string]: string; };
    /**
     * 
     * @type {ProductconfiguratorpropertyGenericProperty}
     * @memberof ProductConfiguratorCreatePropertyRequest
     */
    'genericProperty'?: ProductconfiguratorpropertyGenericProperty;
    /**
     * 
     * @type {ProductconfiguratorpropertyPriceProperty}
     * @memberof ProductConfiguratorCreatePropertyRequest
     */
    'priceProperty'?: ProductconfiguratorpropertyPriceProperty;
    /**
     * 
     * @type {ProductconfiguratorpropertyWeightProperty}
     * @memberof ProductConfiguratorCreatePropertyRequest
     */
    'weightProperty'?: ProductconfiguratorpropertyWeightProperty;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorCreateStepRequest
 */
export interface ProductConfiguratorCreateStepRequest {
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductConfiguratorCreateStepRequest
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductConfiguratorCreateStepRequest
     */
    'description'?: LocalisationLocalizedText;
    /**
     * 
     * @type {boolean}
     * @memberof ProductConfiguratorCreateStepRequest
     */
    'isRequired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorCreateStepRequest
     */
    'subjectToStepId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductConfiguratorCreateStepRequest
     */
    'hasMultipleSelection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductConfiguratorCreateStepRequest
     */
    'optionsHaveQuantity'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorGetAvailableConfiguration2Request
 */
export interface ProductConfiguratorGetAvailableConfiguration2Request {
    /**
     * 
     * @type {Array<ProductconfiguratorconfigurationSelection>}
     * @memberof ProductConfiguratorGetAvailableConfiguration2Request
     */
    'selections'?: Array<ProductconfiguratorconfigurationSelection>;
    /**
     * 
     * @type {Array<ConfigurationPropertyFilter>}
     * @memberof ProductConfiguratorGetAvailableConfiguration2Request
     */
    'propertyFilters'?: Array<ConfigurationPropertyFilter>;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorGetAvailableConfiguration2Request
     */
    'configuratorId'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorGetConfigurationFromSelectionsRequest
 */
export interface ProductConfiguratorGetConfigurationFromSelectionsRequest {
    /**
     * 
     * @type {Array<ProductconfiguratorconfigurationSelection>}
     * @memberof ProductConfiguratorGetConfigurationFromSelectionsRequest
     */
    'selections'?: Array<ProductconfiguratorconfigurationSelection>;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorListDependenciesRequest
 */
export interface ProductConfiguratorListDependenciesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductConfiguratorListDependenciesRequest
     */
    'stepIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorListDependenciesRequest
     */
    'pageToken'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorListMatricesRequest
 */
export interface ProductConfiguratorListMatricesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorListMatricesRequest
     */
    'filterMask'?: string;
    /**
     * 
     * @type {ListMatricesRequestFilter}
     * @memberof ProductConfiguratorListMatricesRequest
     */
    'filter'?: ListMatricesRequestFilter;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorListMatricesRequest
     */
    'pageToken'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorListPropertiesByConfigurationRequest
 */
export interface ProductConfiguratorListPropertiesByConfigurationRequest {
    /**
     * 
     * @type {Array<PropertyListPropertiesByConfigurationRequestSelection>}
     * @memberof ProductConfiguratorListPropertiesByConfigurationRequest
     */
    'selections'?: Array<PropertyListPropertiesByConfigurationRequestSelection>;
    /**
     * 
     * @type {ProductconfiguratorPropertyType}
     * @memberof ProductConfiguratorListPropertiesByConfigurationRequest
     */
    'propertyType'?: ProductconfiguratorPropertyType;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorListPropertiesByConfigurationRequest
     */
    'pageToken'?: string;
}


/**
 * 
 * @export
 * @interface ProductConfiguratorListPropertiesRequest
 */
export interface ProductConfiguratorListPropertiesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorListPropertiesRequest
     */
    'pageToken'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorUpdateConfiguratorRequest
 */
export interface ProductConfiguratorUpdateConfiguratorRequest {
    /**
     * 
     * @type {ProductconfiguratorconfiguratorUpdatePayload}
     * @memberof ProductConfiguratorUpdateConfiguratorRequest
     */
    'payload'?: ProductconfiguratorconfiguratorUpdatePayload;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorUpdateConfiguratorRequest
     */
    'payloadMask'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorUpdateDependencyRequest
 */
export interface ProductConfiguratorUpdateDependencyRequest {
    /**
     * 
     * @type {ProductconfiguratordependencyUpdatePayload}
     * @memberof ProductConfiguratorUpdateDependencyRequest
     */
    'payload'?: ProductconfiguratordependencyUpdatePayload;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorUpdateDependencyRequest
     */
    'payloadMask'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorUpdateMatrixRequest
 */
export interface ProductConfiguratorUpdateMatrixRequest {
    /**
     * 
     * @type {ProductconfiguratormatrixUpdatePayload}
     * @memberof ProductConfiguratorUpdateMatrixRequest
     */
    'payload'?: ProductconfiguratormatrixUpdatePayload;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorUpdateMatrixRequest
     */
    'payloadMask'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorUpdateOptionRequest
 */
export interface ProductConfiguratorUpdateOptionRequest {
    /**
     * 
     * @type {ProductconfiguratoroptionUpdatePayload}
     * @memberof ProductConfiguratorUpdateOptionRequest
     */
    'payload'?: ProductconfiguratoroptionUpdatePayload;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorUpdateOptionRequest
     */
    'payloadMask'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorUpdatePropertyRequest
 */
export interface ProductConfiguratorUpdatePropertyRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorUpdatePropertyRequest
     */
    'matrixId'?: string;
    /**
     * 
     * @type {ProductconfiguratorpropertyUpdatePayload}
     * @memberof ProductConfiguratorUpdatePropertyRequest
     */
    'payload'?: ProductconfiguratorpropertyUpdatePayload;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorUpdatePropertyRequest
     */
    'payloadMask'?: string;
}
/**
 * 
 * @export
 * @interface ProductConfiguratorUpdateStepRequest
 */
export interface ProductConfiguratorUpdateStepRequest {
    /**
     * 
     * @type {ProductconfiguratorstepUpdatePayload}
     * @memberof ProductConfiguratorUpdateStepRequest
     */
    'payload'?: ProductconfiguratorstepUpdatePayload;
    /**
     * 
     * @type {string}
     * @memberof ProductConfiguratorUpdateStepRequest
     */
    'payloadMask'?: string;
}
/**
 * Represents an amount of money.
 * @export
 * @interface ProductconfiguratorMoney
 */
export interface ProductconfiguratorMoney {
    /**
     * The whole units of the amount. For example if `currencyCode` is `\"USD\"`, then 1 unit is one US dollar.
     * @type {string}
     * @memberof ProductconfiguratorMoney
     */
    'units'?: string;
    /**
     * Number of micro (10^-6) units of the amount. The value must be between -999,999 and +999,999 inclusive. If `units` is positive, `micros` must be positive or zero. If `units` is zero, `micros` can be positive, zero, or negative. If `units` is negative, `micros` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `micros`=-750,000.
     * @type {number}
     * @memberof ProductconfiguratorMoney
     */
    'micros'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductconfiguratorPropertyMode = {
    Unknown: 'PROPERTY_MODE_UNKNOWN',
    Final: 'PROPERTY_MODE_FINAL',
    Incremental: 'PROPERTY_MODE_INCREMENTAL'
} as const;

export type ProductconfiguratorPropertyMode = typeof ProductconfiguratorPropertyMode[keyof typeof ProductconfiguratorPropertyMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProductconfiguratorPropertyType = {
    Unknown: 'PROPERTY_TYPE_UNKNOWN',
    Generic: 'PROPERTY_TYPE_GENERIC',
    Price: 'PROPERTY_TYPE_PRICE',
    Weight: 'PROPERTY_TYPE_WEIGHT'
} as const;

export type ProductconfiguratorPropertyType = typeof ProductconfiguratorPropertyType[keyof typeof ProductconfiguratorPropertyType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProductconfiguratorWeightUnit = {
    Unknown: 'WEIGHT_UNIT_UNKNOWN',
    Kilogram: 'WEIGHT_UNIT_KILOGRAM',
    Pound: 'WEIGHT_UNIT_POUND'
} as const;

export type ProductconfiguratorWeightUnit = typeof ProductconfiguratorWeightUnit[keyof typeof ProductconfiguratorWeightUnit];


/**
 * 
 * @export
 * @interface ProductconfiguratorconfigurationOption
 */
export interface ProductconfiguratorconfigurationOption {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfigurationOption
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfigurationOption
     */
    'grn'?: string;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorconfigurationOption
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfigurationOption
     */
    'position'?: string;
    /**
     * 
     * @type {OptionSwatch}
     * @memberof ProductconfiguratorconfigurationOption
     */
    'swatch'?: OptionSwatch;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorconfigurationOption
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<ConfigurationOptionProperty>}
     * @memberof ProductconfiguratorconfigurationOption
     */
    'optionProperties'?: Array<ConfigurationOptionProperty>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorconfigurationOption
     */
    'hasQuantity'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorconfigurationSelection
 */
export interface ProductconfiguratorconfigurationSelection {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfigurationSelection
     */
    'stepId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductconfiguratorconfigurationSelection
     */
    'optionIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorconfigurationStep
 */
export interface ProductconfiguratorconfigurationStep {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'grn'?: string;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'description'?: LocalisationLocalizedText;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'subjectToStepId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'position'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'isRequired'?: boolean;
    /**
     * 
     * @type {Array<ProductconfiguratorconfigurationOption>}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'options'?: Array<ProductconfiguratorconfigurationOption>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorconfigurationStep
     */
    'hasMultipleSelection'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorconfiguratorEntity
 */
export interface ProductconfiguratorconfiguratorEntity {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfiguratorEntity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfiguratorEntity
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfiguratorEntity
     */
    'productId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfiguratorEntity
     */
    'label'?: string;
    /**
     * 
     * @type {ProductconfiguratorconfiguratorStatus}
     * @memberof ProductconfiguratorconfiguratorEntity
     */
    'status'?: ProductconfiguratorconfiguratorStatus;
    /**
     * 
     * @type {Array<ProductconfiguratorstepEntity>}
     * @memberof ProductconfiguratorconfiguratorEntity
     */
    'steps'?: Array<ProductconfiguratorstepEntity>;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfiguratorEntity
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfiguratorEntity
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProductconfiguratorconfiguratorStatus = {
    Unknown: 'UNKNOWN',
    Active: 'ACTIVE',
    Draft: 'DRAFT',
    Disabled: 'DISABLED'
} as const;

export type ProductconfiguratorconfiguratorStatus = typeof ProductconfiguratorconfiguratorStatus[keyof typeof ProductconfiguratorconfiguratorStatus];


/**
 * 
 * @export
 * @interface ProductconfiguratorconfiguratorUpdatePayload
 */
export interface ProductconfiguratorconfiguratorUpdatePayload {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorconfiguratorUpdatePayload
     */
    'label'?: string;
    /**
     * 
     * @type {ProductconfiguratorconfiguratorStatus}
     * @memberof ProductconfiguratorconfiguratorUpdatePayload
     */
    'status'?: ProductconfiguratorconfiguratorStatus;
}


/**
 * 
 * @export
 * @interface ProductconfiguratordependencyEntity
 */
export interface ProductconfiguratordependencyEntity {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratordependencyEntity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratordependencyEntity
     */
    'grn'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductconfiguratordependencyEntity
     */
    'optionIds'?: Array<string>;
    /**
     * 
     * @type {DependencyCondition}
     * @memberof ProductconfiguratordependencyEntity
     */
    'condition'?: DependencyCondition;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratordependencyEntity
     */
    'stepId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratordependencyEntity
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratordependencyEntity
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductconfiguratordependencyType = {
    Unknown: 'UNKNOWN',
    All: 'ALL',
    Any: 'ANY'
} as const;

export type ProductconfiguratordependencyType = typeof ProductconfiguratordependencyType[keyof typeof ProductconfiguratordependencyType];


/**
 * 
 * @export
 * @interface ProductconfiguratordependencyUpdatePayload
 */
export interface ProductconfiguratordependencyUpdatePayload {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductconfiguratordependencyUpdatePayload
     */
    'optionIds'?: Array<string>;
    /**
     * 
     * @type {DependencyCondition}
     * @memberof ProductconfiguratordependencyUpdatePayload
     */
    'condition'?: DependencyCondition;
}
/**
 * 
 * @export
 * @interface ProductconfiguratormatrixEntity
 */
export interface ProductconfiguratormatrixEntity {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixEntity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixEntity
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixEntity
     */
    'configuratorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixEntity
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixEntity
     */
    'defaultPropertyId'?: string;
    /**
     * 
     * @type {ProductconfiguratorPropertyMode}
     * @memberof ProductconfiguratormatrixEntity
     */
    'propertiesMode'?: ProductconfiguratorPropertyMode;
    /**
     * 
     * @type {MatrixGenericType}
     * @memberof ProductconfiguratormatrixEntity
     */
    'genericType'?: MatrixGenericType;
    /**
     * 
     * @type {MatrixPriceType}
     * @memberof ProductconfiguratormatrixEntity
     */
    'priceType'?: MatrixPriceType;
    /**
     * 
     * @type {MatrixWeightType}
     * @memberof ProductconfiguratormatrixEntity
     */
    'weightType'?: MatrixWeightType;
    /**
     * 
     * @type {Array<ProductconfiguratormatrixStep>}
     * @memberof ProductconfiguratormatrixEntity
     */
    'steps'?: Array<ProductconfiguratormatrixStep>;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixEntity
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixEntity
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface ProductconfiguratormatrixStep
 */
export interface ProductconfiguratormatrixStep {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixStep
     */
    'stepId'?: string;
}
/**
 * 
 * @export
 * @interface ProductconfiguratormatrixUpdatePayload
 */
export interface ProductconfiguratormatrixUpdatePayload {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratormatrixUpdatePayload
     */
    'label'?: string;
    /**
     * default_property_id is the id of the property that will be used as the starting point to calculate the differences between the properties.
     * @type {string}
     * @memberof ProductconfiguratormatrixUpdatePayload
     */
    'defaultPropertyId'?: string;
    /**
     * 
     * @type {ProductconfiguratorPropertyMode}
     * @memberof ProductconfiguratormatrixUpdatePayload
     */
    'propertiesMode'?: ProductconfiguratorPropertyMode;
    /**
     * steps are the same as in the create request. This is a full replacement.
     * @type {Array<ProductconfiguratormatrixStep>}
     * @memberof ProductconfiguratormatrixUpdatePayload
     */
    'steps'?: Array<ProductconfiguratormatrixStep>;
}


/**
 * 
 * @export
 * @interface ProductconfiguratoroptionBulkCreateRequestCreateEntity
 */
export interface ProductconfiguratoroptionBulkCreateRequestCreateEntity {
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratoroptionBulkCreateRequestCreateEntity
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionBulkCreateRequestCreateEntity
     */
    'position'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionBulkCreateRequestCreateEntity
     */
    'externalReferenceId'?: string;
    /**
     * 
     * @type {OptionSwatch}
     * @memberof ProductconfiguratoroptionBulkCreateRequestCreateEntity
     */
    'swatch'?: OptionSwatch;
}
/**
 * 
 * @export
 * @interface ProductconfiguratoroptionBulkCreateResponse
 */
export interface ProductconfiguratoroptionBulkCreateResponse {
    /**
     * 
     * @type {Array<ProductconfiguratoroptionEntity>}
     * @memberof ProductconfiguratoroptionBulkCreateResponse
     */
    'options'?: Array<ProductconfiguratoroptionEntity>;
}
/**
 * 
 * @export
 * @interface ProductconfiguratoroptionBulkUpdateRequestUpdateEntity
 */
export interface ProductconfiguratoroptionBulkUpdateRequestUpdateEntity {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionBulkUpdateRequestUpdateEntity
     */
    'optionId'?: string;
    /**
     * 
     * @type {ProductconfiguratoroptionUpdatePayload}
     * @memberof ProductconfiguratoroptionBulkUpdateRequestUpdateEntity
     */
    'payload'?: ProductconfiguratoroptionUpdatePayload;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionBulkUpdateRequestUpdateEntity
     */
    'payloadMask'?: string;
}
/**
 * 
 * @export
 * @interface ProductconfiguratoroptionBulkUpdateResponse
 */
export interface ProductconfiguratoroptionBulkUpdateResponse {
    /**
     * 
     * @type {Array<ProductconfiguratoroptionEntity>}
     * @memberof ProductconfiguratoroptionBulkUpdateResponse
     */
    'options'?: Array<ProductconfiguratoroptionEntity>;
}
/**
 * 
 * @export
 * @interface ProductconfiguratoroptionEntity
 */
export interface ProductconfiguratoroptionEntity {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionEntity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionEntity
     */
    'grn'?: string;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratoroptionEntity
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionEntity
     */
    'position'?: string;
    /**
     * 
     * @type {OptionSwatch}
     * @memberof ProductconfiguratoroptionEntity
     */
    'swatch'?: OptionSwatch;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionEntity
     */
    'externalReferenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionEntity
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionEntity
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProductconfiguratoroptionUpdatePayload
 */
export interface ProductconfiguratoroptionUpdatePayload {
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratoroptionUpdatePayload
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionUpdatePayload
     */
    'position'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratoroptionUpdatePayload
     */
    'externalReferenceId'?: string;
    /**
     * 
     * @type {OptionSwatch}
     * @memberof ProductconfiguratoroptionUpdatePayload
     */
    'swatch'?: OptionSwatch;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyBulkCreateRequestCreateEntity
 */
export interface ProductconfiguratorpropertyBulkCreateRequestCreateEntity {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProductconfiguratorpropertyBulkCreateRequestCreateEntity
     */
    'stepIdToOptionId'?: { [key: string]: string; };
    /**
     * 
     * @type {ProductconfiguratorpropertyGenericProperty}
     * @memberof ProductconfiguratorpropertyBulkCreateRequestCreateEntity
     */
    'genericProperty'?: ProductconfiguratorpropertyGenericProperty;
    /**
     * 
     * @type {ProductconfiguratorpropertyPriceProperty}
     * @memberof ProductconfiguratorpropertyBulkCreateRequestCreateEntity
     */
    'priceProperty'?: ProductconfiguratorpropertyPriceProperty;
    /**
     * 
     * @type {ProductconfiguratorpropertyWeightProperty}
     * @memberof ProductconfiguratorpropertyBulkCreateRequestCreateEntity
     */
    'weightProperty'?: ProductconfiguratorpropertyWeightProperty;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyBulkCreateResponse
 */
export interface ProductconfiguratorpropertyBulkCreateResponse {
    /**
     * 
     * @type {Array<ProductconfiguratorpropertyEntity>}
     * @memberof ProductconfiguratorpropertyBulkCreateResponse
     */
    'properties'?: Array<ProductconfiguratorpropertyEntity>;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyBulkUpdateRequestUpdateEntity
 */
export interface ProductconfiguratorpropertyBulkUpdateRequestUpdateEntity {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyBulkUpdateRequestUpdateEntity
     */
    'propertyId'?: string;
    /**
     * 
     * @type {ProductconfiguratorpropertyUpdatePayload}
     * @memberof ProductconfiguratorpropertyBulkUpdateRequestUpdateEntity
     */
    'payload'?: ProductconfiguratorpropertyUpdatePayload;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyBulkUpdateRequestUpdateEntity
     */
    'payloadMask'?: string;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyBulkUpdateResponse
 */
export interface ProductconfiguratorpropertyBulkUpdateResponse {
    /**
     * 
     * @type {Array<ProductconfiguratorpropertyEntity>}
     * @memberof ProductconfiguratorpropertyBulkUpdateResponse
     */
    'properties'?: Array<ProductconfiguratorpropertyEntity>;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyEntity
 */
export interface ProductconfiguratorpropertyEntity {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyEntity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyEntity
     */
    'grn'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProductconfiguratorpropertyEntity
     */
    'stepIdToOptionId'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyEntity
     */
    'propertyKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyEntity
     */
    'propertyValue'?: string;
    /**
     * 
     * @type {ProductconfiguratorPropertyType}
     * @memberof ProductconfiguratorpropertyEntity
     */
    'propertyType'?: ProductconfiguratorPropertyType;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyEntity
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyEntity
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyGenericProperty
 */
export interface ProductconfiguratorpropertyGenericProperty {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyGenericProperty
     */
    'propertyKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyGenericProperty
     */
    'propertyValue'?: string;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyPriceProperty
 */
export interface ProductconfiguratorpropertyPriceProperty {
    /**
     * 
     * @type {ProductconfiguratorMoney}
     * @memberof ProductconfiguratorpropertyPriceProperty
     */
    'price'?: ProductconfiguratorMoney;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorpropertyPriceProperty
     */
    'pricelistGrn'?: string;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyUpdatePayload
 */
export interface ProductconfiguratorpropertyUpdatePayload {
    /**
     * 
     * @type {PropertyUpdatePayloadGenericProperty}
     * @memberof ProductconfiguratorpropertyUpdatePayload
     */
    'genericProperty'?: PropertyUpdatePayloadGenericProperty;
    /**
     * 
     * @type {PropertyUpdatePayloadWeightProperty}
     * @memberof ProductconfiguratorpropertyUpdatePayload
     */
    'weightProperty'?: PropertyUpdatePayloadWeightProperty;
    /**
     * 
     * @type {PropertyUpdatePayloadPriceProperty}
     * @memberof ProductconfiguratorpropertyUpdatePayload
     */
    'priceProperty'?: PropertyUpdatePayloadPriceProperty;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorpropertyWeightProperty
 */
export interface ProductconfiguratorpropertyWeightProperty {
    /**
     * 
     * @type {number}
     * @memberof ProductconfiguratorpropertyWeightProperty
     */
    'weight'?: number;
    /**
     * 
     * @type {ProductconfiguratorWeightUnit}
     * @memberof ProductconfiguratorpropertyWeightProperty
     */
    'weightUnit'?: ProductconfiguratorWeightUnit;
}


/**
 * 
 * @export
 * @interface ProductconfiguratorstepBulkCreateRequestCreateEntity
 */
export interface ProductconfiguratorstepBulkCreateRequestCreateEntity {
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorstepBulkCreateRequestCreateEntity
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorstepBulkCreateRequestCreateEntity
     */
    'description'?: LocalisationLocalizedText;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepBulkCreateRequestCreateEntity
     */
    'isRequired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepBulkCreateRequestCreateEntity
     */
    'subjectToStepId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepBulkCreateRequestCreateEntity
     */
    'hasMultipleSelection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepBulkCreateRequestCreateEntity
     */
    'optionsHaveQuantity'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorstepBulkCreateResponse
 */
export interface ProductconfiguratorstepBulkCreateResponse {
    /**
     * 
     * @type {Array<ProductconfiguratorstepEntity>}
     * @memberof ProductconfiguratorstepBulkCreateResponse
     */
    'steps'?: Array<ProductconfiguratorstepEntity>;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorstepEntity
 */
export interface ProductconfiguratorstepEntity {
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepEntity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepEntity
     */
    'grn'?: string;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorstepEntity
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorstepEntity
     */
    'description'?: LocalisationLocalizedText;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepEntity
     */
    'subjectToStepId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepEntity
     */
    'position'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepEntity
     */
    'isRequired'?: boolean;
    /**
     * 
     * @type {Array<ProductconfiguratoroptionEntity>}
     * @memberof ProductconfiguratorstepEntity
     */
    'options'?: Array<ProductconfiguratoroptionEntity>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepEntity
     */
    'hasMultipleSelection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepEntity
     */
    'optionsHaveQuantity'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepEntity
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepEntity
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProductconfiguratorstepUpdatePayload
 */
export interface ProductconfiguratorstepUpdatePayload {
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorstepUpdatePayload
     */
    'label'?: LocalisationLocalizedText;
    /**
     * 
     * @type {LocalisationLocalizedText}
     * @memberof ProductconfiguratorstepUpdatePayload
     */
    'description'?: LocalisationLocalizedText;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepUpdatePayload
     */
    'position'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepUpdatePayload
     */
    'isRequired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductconfiguratorstepUpdatePayload
     */
    'subjectToStepId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepUpdatePayload
     */
    'hasMultipleSelection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductconfiguratorstepUpdatePayload
     */
    'optionsHaveQuantity'?: boolean;
}
/**
 * 
 * @export
 * @interface PropertyListPropertiesByConfigurationRequestSelection
 */
export interface PropertyListPropertiesByConfigurationRequestSelection {
    /**
     * 
     * @type {string}
     * @memberof PropertyListPropertiesByConfigurationRequestSelection
     */
    'stepId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyListPropertiesByConfigurationRequestSelection
     */
    'optionId'?: string;
}
/**
 * 
 * @export
 * @interface PropertyListPropertiesByConfigurationResponse
 */
export interface PropertyListPropertiesByConfigurationResponse {
    /**
     * 
     * @type {Array<ProductconfiguratorpropertyEntity>}
     * @memberof PropertyListPropertiesByConfigurationResponse
     */
    'properties'?: Array<ProductconfiguratorpropertyEntity>;
    /**
     * 
     * @type {string}
     * @memberof PropertyListPropertiesByConfigurationResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface PropertyListPropertiesResponse
 */
export interface PropertyListPropertiesResponse {
    /**
     * 
     * @type {Array<ProductconfiguratorpropertyEntity>}
     * @memberof PropertyListPropertiesResponse
     */
    'properties'?: Array<ProductconfiguratorpropertyEntity>;
    /**
     * 
     * @type {string}
     * @memberof PropertyListPropertiesResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface PropertyUpdatePayloadGenericProperty
 */
export interface PropertyUpdatePayloadGenericProperty {
    /**
     * 
     * @type {string}
     * @memberof PropertyUpdatePayloadGenericProperty
     */
    'propertyValue'?: string;
}
/**
 * 
 * @export
 * @interface PropertyUpdatePayloadPriceProperty
 */
export interface PropertyUpdatePayloadPriceProperty {
    /**
     * 
     * @type {ProductconfiguratorMoney}
     * @memberof PropertyUpdatePayloadPriceProperty
     */
    'price'?: ProductconfiguratorMoney;
    /**
     * 
     * @type {string}
     * @memberof PropertyUpdatePayloadPriceProperty
     */
    'pricelistGrn'?: string;
}
/**
 * 
 * @export
 * @interface PropertyUpdatePayloadWeightProperty
 */
export interface PropertyUpdatePayloadWeightProperty {
    /**
     * 
     * @type {number}
     * @memberof PropertyUpdatePayloadWeightProperty
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}

/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve available configurations for a specific product and tenant. Use a GET request for read-only access or submit additional criteria in the body of a POST request for tailored configuration results. Streamline the retrieval of configurations effortlessly.
         * @summary Get Available Configuration
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {string} [configuratorId] If not set, the service returns the active configurator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetAvailableConfiguration: async (tenantId: string, productId: string, configuratorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorGetAvailableConfiguration', 'tenantId', tenantId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productConfiguratorGetAvailableConfiguration', 'productId', productId)
            const localVarPath = `/v1/{tenantId}/product/{productId}/configuration`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (configuratorId !== undefined) {
                localVarQueryParameter['configuratorId'] = configuratorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve available configurations for a specific product and tenant. Use a GET request for read-only access or submit additional criteria in the body of a POST request for tailored configuration results. Streamline the retrieval of configurations effortlessly.
         * @summary Get Available Configuration
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetAvailableConfiguration2Request} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetAvailableConfiguration2: async (tenantId: string, productId: string, body: ProductConfiguratorGetAvailableConfiguration2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorGetAvailableConfiguration2', 'tenantId', tenantId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productConfiguratorGetAvailableConfiguration2', 'productId', productId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorGetAvailableConfiguration2', 'body', body)
            const localVarPath = `/v1/{tenantId}/product/{productId}/configuration`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a configuration based on user selections for a specific product and tenant. Submit a POST request with user selections in the body to receive a tailored configuration. Enhance the user experience by dynamically generating configurations based on user input.
         * @summary Get Configuration from Selections
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfigurationFromSelectionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetConfigurationFromSelections: async (tenantId: string, productId: string, body: ProductConfiguratorGetConfigurationFromSelectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorGetConfigurationFromSelections', 'tenantId', tenantId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productConfiguratorGetConfigurationFromSelections', 'productId', productId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorGetConfigurationFromSelections', 'body', body)
            const localVarPath = `/v1/{tenantId}/product/{productId}/configuration-from-selections`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve available configurations for a specific product and tenant. Use a GET request for read-only access or submit additional criteria in the body of a POST request for tailored configuration results. Streamline the retrieval of configurations effortlessly.
         * @summary Get Available Configuration
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {string} [configuratorId] If not set, the service returns the active configurator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorGetAvailableConfiguration(tenantId: string, productId: string, configuratorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationGetAvailableConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorGetAvailableConfiguration(tenantId, productId, configuratorId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfigurationApi.productConfiguratorGetAvailableConfiguration']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve available configurations for a specific product and tenant. Use a GET request for read-only access or submit additional criteria in the body of a POST request for tailored configuration results. Streamline the retrieval of configurations effortlessly.
         * @summary Get Available Configuration
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetAvailableConfiguration2Request} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorGetAvailableConfiguration2(tenantId: string, productId: string, body: ProductConfiguratorGetAvailableConfiguration2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationGetAvailableConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorGetAvailableConfiguration2(tenantId, productId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfigurationApi.productConfiguratorGetAvailableConfiguration2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a configuration based on user selections for a specific product and tenant. Submit a POST request with user selections in the body to receive a tailored configuration. Enhance the user experience by dynamically generating configurations based on user input.
         * @summary Get Configuration from Selections
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfigurationFromSelectionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorGetConfigurationFromSelections(tenantId: string, productId: string, body: ProductConfiguratorGetConfigurationFromSelectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationGetConfigurationFromSelectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorGetConfigurationFromSelections(tenantId, productId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfigurationApi.productConfiguratorGetConfigurationFromSelections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigurationApiFp(configuration)
    return {
        /**
         * Retrieve available configurations for a specific product and tenant. Use a GET request for read-only access or submit additional criteria in the body of a POST request for tailored configuration results. Streamline the retrieval of configurations effortlessly.
         * @summary Get Available Configuration
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {string} [configuratorId] If not set, the service returns the active configurator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetAvailableConfiguration(tenantId: string, productId: string, configuratorId?: string, options?: any): AxiosPromise<ConfigurationGetAvailableConfigurationResponse> {
            return localVarFp.productConfiguratorGetAvailableConfiguration(tenantId, productId, configuratorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve available configurations for a specific product and tenant. Use a GET request for read-only access or submit additional criteria in the body of a POST request for tailored configuration results. Streamline the retrieval of configurations effortlessly.
         * @summary Get Available Configuration
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetAvailableConfiguration2Request} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetAvailableConfiguration2(tenantId: string, productId: string, body: ProductConfiguratorGetAvailableConfiguration2Request, options?: any): AxiosPromise<ConfigurationGetAvailableConfigurationResponse> {
            return localVarFp.productConfiguratorGetAvailableConfiguration2(tenantId, productId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a configuration based on user selections for a specific product and tenant. Submit a POST request with user selections in the body to receive a tailored configuration. Enhance the user experience by dynamically generating configurations based on user input.
         * @summary Get Configuration from Selections
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfigurationFromSelectionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetConfigurationFromSelections(tenantId: string, productId: string, body: ProductConfiguratorGetConfigurationFromSelectionsRequest, options?: any): AxiosPromise<ConfigurationGetConfigurationFromSelectionsResponse> {
            return localVarFp.productConfiguratorGetConfigurationFromSelections(tenantId, productId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
    /**
     * Retrieve available configurations for a specific product and tenant. Use a GET request for read-only access or submit additional criteria in the body of a POST request for tailored configuration results. Streamline the retrieval of configurations effortlessly.
     * @summary Get Available Configuration
     * @param {string} tenantId 
     * @param {string} productId 
     * @param {string} [configuratorId] If not set, the service returns the active configurator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public productConfiguratorGetAvailableConfiguration(tenantId: string, productId: string, configuratorId?: string, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).productConfiguratorGetAvailableConfiguration(tenantId, productId, configuratorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve available configurations for a specific product and tenant. Use a GET request for read-only access or submit additional criteria in the body of a POST request for tailored configuration results. Streamline the retrieval of configurations effortlessly.
     * @summary Get Available Configuration
     * @param {string} tenantId 
     * @param {string} productId 
     * @param {ProductConfiguratorGetAvailableConfiguration2Request} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public productConfiguratorGetAvailableConfiguration2(tenantId: string, productId: string, body: ProductConfiguratorGetAvailableConfiguration2Request, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).productConfiguratorGetAvailableConfiguration2(tenantId, productId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a configuration based on user selections for a specific product and tenant. Submit a POST request with user selections in the body to receive a tailored configuration. Enhance the user experience by dynamically generating configurations based on user input.
     * @summary Get Configuration from Selections
     * @param {string} tenantId 
     * @param {string} productId 
     * @param {ProductConfiguratorGetConfigurationFromSelectionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public productConfiguratorGetConfigurationFromSelections(tenantId: string, productId: string, body: ProductConfiguratorGetConfigurationFromSelectionsRequest, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).productConfiguratorGetConfigurationFromSelections(tenantId, productId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfiguratorApi - axios parameter creator
 * @export
 */
export const ConfiguratorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Duplicate an existing product configurator from the source to the specified tenant and product. Submit an empty body to initiate the copy process, creating a new configuration based on the source.
         * @summary Copy Configurator
         * @param {string} tenantId 
         * @param {string} sourceConfiguratorId 
         * @param {ProductConfiguratorCopyConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCopyConfigurator: async (tenantId: string, sourceConfiguratorId: string, body: ProductConfiguratorCopyConfiguratorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCopyConfigurator', 'tenantId', tenantId)
            // verify required parameter 'sourceConfiguratorId' is not null or undefined
            assertParamExists('productConfiguratorCopyConfigurator', 'sourceConfiguratorId', sourceConfiguratorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCopyConfigurator', 'body', body)
            const localVarPath = `/v1/{tenantId}/product/{sourceConfiguratorId}/copy`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"sourceConfiguratorId"}}`, encodeURIComponent(String(sourceConfiguratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new product configurator for a specified tenant and product. Submit the desired configuration details in the request body to initiate the creation process.
         * @summary Create Configurator
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorCreateConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateConfigurator: async (tenantId: string, productId: string, body: ProductConfiguratorCreateConfiguratorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCreateConfigurator', 'tenantId', tenantId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productConfiguratorCreateConfigurator', 'productId', productId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCreateConfigurator', 'body', body)
            const localVarPath = `/v1/{tenantId}/product/{productId}/create`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a product configurator by specifying the tenant and configurator IDs. Ensure precise removal of unwanted configurations with a straightforward DELETE request.
         * @summary Delete Configurator
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteConfigurator: async (tenantId: string, configuratorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorDeleteConfigurator', 'tenantId', tenantId)
            // verify required parameter 'configuratorId' is not null or undefined
            assertParamExists('productConfiguratorDeleteConfigurator', 'configuratorId', configuratorId)
            const localVarPath = `/v1/{tenantId}/configurator/{configuratorId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"configuratorId"}}`, encodeURIComponent(String(configuratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve product configurations with status details, filtered by product and tenant IDs. Flexible options for specifying additional status parameters.
         * @summary Get Configurator by Product ID
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfiguratorByProductIdStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetConfiguratorByProductId: async (tenantId: string, productId: string, status?: ProductConfiguratorGetConfiguratorByProductIdStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorGetConfiguratorByProductId', 'tenantId', tenantId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productConfiguratorGetConfiguratorByProductId', 'productId', productId)
            const localVarPath = `/v1/{tenantId}/product/{productId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve product configurations with status details, filtered by product and tenant IDs. Flexible options for specifying additional status parameters.
         * @summary Get Configurator by Product ID
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfiguratorByProductId2StatusEnum} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetConfiguratorByProductId2: async (tenantId: string, productId: string, status: ProductConfiguratorGetConfiguratorByProductId2StatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorGetConfiguratorByProductId2', 'tenantId', tenantId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productConfiguratorGetConfiguratorByProductId2', 'productId', productId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('productConfiguratorGetConfiguratorByProductId2', 'status', status)
            const localVarPath = `/v1/{tenantId}/product/{productId}/status/{status}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all product configurators.
         * @summary List Product Configurators
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListConfigurators: async (tenantId: string, productId: string, pageSize: number, body: ProductConfiguratorListPropertiesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorListConfigurators', 'tenantId', tenantId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productConfiguratorListConfigurators', 'productId', productId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('productConfiguratorListConfigurators', 'pageSize', pageSize)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorListConfigurators', 'body', body)
            const localVarPath = `/v1/{tenantId}/product/{productId}/page-size/{pageSize}/configurators`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing product configurator by specifying the tenant and configurator IDs. Use a PUT request with the updated configuration details in the body to seamlessly update and manage product configurations
         * @summary Update Configurator
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorUpdateConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateConfigurator: async (tenantId: string, configuratorId: string, body: ProductConfiguratorUpdateConfiguratorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorUpdateConfigurator', 'tenantId', tenantId)
            // verify required parameter 'configuratorId' is not null or undefined
            assertParamExists('productConfiguratorUpdateConfigurator', 'configuratorId', configuratorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorUpdateConfigurator', 'body', body)
            const localVarPath = `/v1/{tenantId}/configurator/{configuratorId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"configuratorId"}}`, encodeURIComponent(String(configuratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfiguratorApi - functional programming interface
 * @export
 */
export const ConfiguratorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfiguratorApiAxiosParamCreator(configuration)
    return {
        /**
         * Duplicate an existing product configurator from the source to the specified tenant and product. Submit an empty body to initiate the copy process, creating a new configuration based on the source.
         * @summary Copy Configurator
         * @param {string} tenantId 
         * @param {string} sourceConfiguratorId 
         * @param {ProductConfiguratorCopyConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCopyConfigurator(tenantId: string, sourceConfiguratorId: string, body: ProductConfiguratorCopyConfiguratorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorconfiguratorEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCopyConfigurator(tenantId, sourceConfiguratorId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfiguratorApi.productConfiguratorCopyConfigurator']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new product configurator for a specified tenant and product. Submit the desired configuration details in the request body to initiate the creation process.
         * @summary Create Configurator
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorCreateConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCreateConfigurator(tenantId: string, productId: string, body: ProductConfiguratorCreateConfiguratorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorconfiguratorEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCreateConfigurator(tenantId, productId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfiguratorApi.productConfiguratorCreateConfigurator']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a product configurator by specifying the tenant and configurator IDs. Ensure precise removal of unwanted configurations with a straightforward DELETE request.
         * @summary Delete Configurator
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorDeleteConfigurator(tenantId: string, configuratorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorDeleteConfigurator(tenantId, configuratorId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfiguratorApi.productConfiguratorDeleteConfigurator']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve product configurations with status details, filtered by product and tenant IDs. Flexible options for specifying additional status parameters.
         * @summary Get Configurator by Product ID
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfiguratorByProductIdStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorGetConfiguratorByProductId(tenantId: string, productId: string, status?: ProductConfiguratorGetConfiguratorByProductIdStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorconfiguratorEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorGetConfiguratorByProductId(tenantId, productId, status, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfiguratorApi.productConfiguratorGetConfiguratorByProductId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve product configurations with status details, filtered by product and tenant IDs. Flexible options for specifying additional status parameters.
         * @summary Get Configurator by Product ID
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfiguratorByProductId2StatusEnum} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorGetConfiguratorByProductId2(tenantId: string, productId: string, status: ProductConfiguratorGetConfiguratorByProductId2StatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorconfiguratorEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorGetConfiguratorByProductId2(tenantId, productId, status, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfiguratorApi.productConfiguratorGetConfiguratorByProductId2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all product configurators.
         * @summary List Product Configurators
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorListConfigurators(tenantId: string, productId: string, pageSize: number, body: ProductConfiguratorListPropertiesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfiguratorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorListConfigurators(tenantId, productId, pageSize, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfiguratorApi.productConfiguratorListConfigurators']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modify an existing product configurator by specifying the tenant and configurator IDs. Use a PUT request with the updated configuration details in the body to seamlessly update and manage product configurations
         * @summary Update Configurator
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorUpdateConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorUpdateConfigurator(tenantId: string, configuratorId: string, body: ProductConfiguratorUpdateConfiguratorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorconfiguratorEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorUpdateConfigurator(tenantId, configuratorId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConfiguratorApi.productConfiguratorUpdateConfigurator']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ConfiguratorApi - factory interface
 * @export
 */
export const ConfiguratorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfiguratorApiFp(configuration)
    return {
        /**
         * Duplicate an existing product configurator from the source to the specified tenant and product. Submit an empty body to initiate the copy process, creating a new configuration based on the source.
         * @summary Copy Configurator
         * @param {string} tenantId 
         * @param {string} sourceConfiguratorId 
         * @param {ProductConfiguratorCopyConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCopyConfigurator(tenantId: string, sourceConfiguratorId: string, body: ProductConfiguratorCopyConfiguratorRequest, options?: any): AxiosPromise<ProductconfiguratorconfiguratorEntity> {
            return localVarFp.productConfiguratorCopyConfigurator(tenantId, sourceConfiguratorId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new product configurator for a specified tenant and product. Submit the desired configuration details in the request body to initiate the creation process.
         * @summary Create Configurator
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorCreateConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateConfigurator(tenantId: string, productId: string, body: ProductConfiguratorCreateConfiguratorRequest, options?: any): AxiosPromise<ProductconfiguratorconfiguratorEntity> {
            return localVarFp.productConfiguratorCreateConfigurator(tenantId, productId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a product configurator by specifying the tenant and configurator IDs. Ensure precise removal of unwanted configurations with a straightforward DELETE request.
         * @summary Delete Configurator
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteConfigurator(tenantId: string, configuratorId: string, options?: any): AxiosPromise<object> {
            return localVarFp.productConfiguratorDeleteConfigurator(tenantId, configuratorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve product configurations with status details, filtered by product and tenant IDs. Flexible options for specifying additional status parameters.
         * @summary Get Configurator by Product ID
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfiguratorByProductIdStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetConfiguratorByProductId(tenantId: string, productId: string, status?: ProductConfiguratorGetConfiguratorByProductIdStatusEnum, options?: any): AxiosPromise<ProductconfiguratorconfiguratorEntity> {
            return localVarFp.productConfiguratorGetConfiguratorByProductId(tenantId, productId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve product configurations with status details, filtered by product and tenant IDs. Flexible options for specifying additional status parameters.
         * @summary Get Configurator by Product ID
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {ProductConfiguratorGetConfiguratorByProductId2StatusEnum} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetConfiguratorByProductId2(tenantId: string, productId: string, status: ProductConfiguratorGetConfiguratorByProductId2StatusEnum, options?: any): AxiosPromise<ProductconfiguratorconfiguratorEntity> {
            return localVarFp.productConfiguratorGetConfiguratorByProductId2(tenantId, productId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * List all product configurators.
         * @summary List Product Configurators
         * @param {string} tenantId 
         * @param {string} productId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListConfigurators(tenantId: string, productId: string, pageSize: number, body: ProductConfiguratorListPropertiesRequest, options?: any): AxiosPromise<ConfiguratorListResponse> {
            return localVarFp.productConfiguratorListConfigurators(tenantId, productId, pageSize, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing product configurator by specifying the tenant and configurator IDs. Use a PUT request with the updated configuration details in the body to seamlessly update and manage product configurations
         * @summary Update Configurator
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorUpdateConfiguratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateConfigurator(tenantId: string, configuratorId: string, body: ProductConfiguratorUpdateConfiguratorRequest, options?: any): AxiosPromise<ProductconfiguratorconfiguratorEntity> {
            return localVarFp.productConfiguratorUpdateConfigurator(tenantId, configuratorId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfiguratorApi - object-oriented interface
 * @export
 * @class ConfiguratorApi
 * @extends {BaseAPI}
 */
export class ConfiguratorApi extends BaseAPI {
    /**
     * Duplicate an existing product configurator from the source to the specified tenant and product. Submit an empty body to initiate the copy process, creating a new configuration based on the source.
     * @summary Copy Configurator
     * @param {string} tenantId 
     * @param {string} sourceConfiguratorId 
     * @param {ProductConfiguratorCopyConfiguratorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfiguratorApi
     */
    public productConfiguratorCopyConfigurator(tenantId: string, sourceConfiguratorId: string, body: ProductConfiguratorCopyConfiguratorRequest, options?: RawAxiosRequestConfig) {
        return ConfiguratorApiFp(this.configuration).productConfiguratorCopyConfigurator(tenantId, sourceConfiguratorId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new product configurator for a specified tenant and product. Submit the desired configuration details in the request body to initiate the creation process.
     * @summary Create Configurator
     * @param {string} tenantId 
     * @param {string} productId 
     * @param {ProductConfiguratorCreateConfiguratorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfiguratorApi
     */
    public productConfiguratorCreateConfigurator(tenantId: string, productId: string, body: ProductConfiguratorCreateConfiguratorRequest, options?: RawAxiosRequestConfig) {
        return ConfiguratorApiFp(this.configuration).productConfiguratorCreateConfigurator(tenantId, productId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a product configurator by specifying the tenant and configurator IDs. Ensure precise removal of unwanted configurations with a straightforward DELETE request.
     * @summary Delete Configurator
     * @param {string} tenantId 
     * @param {string} configuratorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfiguratorApi
     */
    public productConfiguratorDeleteConfigurator(tenantId: string, configuratorId: string, options?: RawAxiosRequestConfig) {
        return ConfiguratorApiFp(this.configuration).productConfiguratorDeleteConfigurator(tenantId, configuratorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve product configurations with status details, filtered by product and tenant IDs. Flexible options for specifying additional status parameters.
     * @summary Get Configurator by Product ID
     * @param {string} tenantId 
     * @param {string} productId 
     * @param {ProductConfiguratorGetConfiguratorByProductIdStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfiguratorApi
     */
    public productConfiguratorGetConfiguratorByProductId(tenantId: string, productId: string, status?: ProductConfiguratorGetConfiguratorByProductIdStatusEnum, options?: RawAxiosRequestConfig) {
        return ConfiguratorApiFp(this.configuration).productConfiguratorGetConfiguratorByProductId(tenantId, productId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve product configurations with status details, filtered by product and tenant IDs. Flexible options for specifying additional status parameters.
     * @summary Get Configurator by Product ID
     * @param {string} tenantId 
     * @param {string} productId 
     * @param {ProductConfiguratorGetConfiguratorByProductId2StatusEnum} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfiguratorApi
     */
    public productConfiguratorGetConfiguratorByProductId2(tenantId: string, productId: string, status: ProductConfiguratorGetConfiguratorByProductId2StatusEnum, options?: RawAxiosRequestConfig) {
        return ConfiguratorApiFp(this.configuration).productConfiguratorGetConfiguratorByProductId2(tenantId, productId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all product configurators.
     * @summary List Product Configurators
     * @param {string} tenantId 
     * @param {string} productId 
     * @param {number} pageSize 
     * @param {ProductConfiguratorListPropertiesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfiguratorApi
     */
    public productConfiguratorListConfigurators(tenantId: string, productId: string, pageSize: number, body: ProductConfiguratorListPropertiesRequest, options?: RawAxiosRequestConfig) {
        return ConfiguratorApiFp(this.configuration).productConfiguratorListConfigurators(tenantId, productId, pageSize, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify an existing product configurator by specifying the tenant and configurator IDs. Use a PUT request with the updated configuration details in the body to seamlessly update and manage product configurations
     * @summary Update Configurator
     * @param {string} tenantId 
     * @param {string} configuratorId 
     * @param {ProductConfiguratorUpdateConfiguratorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfiguratorApi
     */
    public productConfiguratorUpdateConfigurator(tenantId: string, configuratorId: string, body: ProductConfiguratorUpdateConfiguratorRequest, options?: RawAxiosRequestConfig) {
        return ConfiguratorApiFp(this.configuration).productConfiguratorUpdateConfigurator(tenantId, configuratorId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProductConfiguratorGetConfiguratorByProductIdStatusEnum = {
    Unknown: 'UNKNOWN',
    Active: 'ACTIVE',
    Draft: 'DRAFT',
    Disabled: 'DISABLED'
} as const;
export type ProductConfiguratorGetConfiguratorByProductIdStatusEnum = typeof ProductConfiguratorGetConfiguratorByProductIdStatusEnum[keyof typeof ProductConfiguratorGetConfiguratorByProductIdStatusEnum];
/**
 * @export
 */
export const ProductConfiguratorGetConfiguratorByProductId2StatusEnum = {
    Unknown: 'UNKNOWN',
    Active: 'ACTIVE',
    Draft: 'DRAFT',
    Disabled: 'DISABLED'
} as const;
export type ProductConfiguratorGetConfiguratorByProductId2StatusEnum = typeof ProductConfiguratorGetConfiguratorByProductId2StatusEnum[keyof typeof ProductConfiguratorGetConfiguratorByProductId2StatusEnum];


/**
 * DependencyApi - axios parameter creator
 * @export
 */
export const DependencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Establish a new dependency for an existing step by specifying the tenant and step IDs. Utilize a POST request with the required dependency details in the body to seamlessly enhance the configuration logic of your product.
         * @summary Create Dependency
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorCreateDependencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateDependency: async (tenantId: string, stepId: string, body: ProductConfiguratorCreateDependencyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCreateDependency', 'tenantId', tenantId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('productConfiguratorCreateDependency', 'stepId', stepId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCreateDependency', 'body', body)
            const localVarPath = `/v1/{tenantId}/step/{stepId}/dependency/create`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a specific dependency by specifying the tenant and dependency IDs. Ensure precision in dependency management with a straightforward DELETE request, simplifying the elimination of unwanted configuration logic.
         * @summary Delete Dependency
         * @param {string} tenantId 
         * @param {string} dependencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteDependency: async (tenantId: string, dependencyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorDeleteDependency', 'tenantId', tenantId)
            // verify required parameter 'dependencyId' is not null or undefined
            assertParamExists('productConfiguratorDeleteDependency', 'dependencyId', dependencyId)
            const localVarPath = `/v1/{tenantId}/dependency/{dependencyId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"dependencyId"}}`, encodeURIComponent(String(dependencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of dependencies based on the specified tenant ID. Customize results by specifying page size for efficient pagination. Submit an empty body to get all dependencies associated with the configurations.
         * @summary List Dependencies
         * @param {string} tenantId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListDependenciesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListDependencies: async (tenantId: string, pageSize: number, body: ProductConfiguratorListDependenciesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorListDependencies', 'tenantId', tenantId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('productConfiguratorListDependencies', 'pageSize', pageSize)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorListDependencies', 'body', body)
            const localVarPath = `/v1/{tenantId}/page-size/{pageSize}/dependencies`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing dependency by specifying the tenant and dependency IDs. Utilize a PUT request with updated dependency details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Dependency
         * @param {string} tenantId 
         * @param {string} dependencyId 
         * @param {ProductConfiguratorUpdateDependencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateDependency: async (tenantId: string, dependencyId: string, body: ProductConfiguratorUpdateDependencyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorUpdateDependency', 'tenantId', tenantId)
            // verify required parameter 'dependencyId' is not null or undefined
            assertParamExists('productConfiguratorUpdateDependency', 'dependencyId', dependencyId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorUpdateDependency', 'body', body)
            const localVarPath = `/v1/{tenantId}/dependency/{dependencyId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"dependencyId"}}`, encodeURIComponent(String(dependencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DependencyApi - functional programming interface
 * @export
 */
export const DependencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DependencyApiAxiosParamCreator(configuration)
    return {
        /**
         * Establish a new dependency for an existing step by specifying the tenant and step IDs. Utilize a POST request with the required dependency details in the body to seamlessly enhance the configuration logic of your product.
         * @summary Create Dependency
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorCreateDependencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCreateDependency(tenantId: string, stepId: string, body: ProductConfiguratorCreateDependencyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratordependencyEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCreateDependency(tenantId, stepId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DependencyApi.productConfiguratorCreateDependency']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove a specific dependency by specifying the tenant and dependency IDs. Ensure precision in dependency management with a straightforward DELETE request, simplifying the elimination of unwanted configuration logic.
         * @summary Delete Dependency
         * @param {string} tenantId 
         * @param {string} dependencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorDeleteDependency(tenantId: string, dependencyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorDeleteDependency(tenantId, dependencyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DependencyApi.productConfiguratorDeleteDependency']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a list of dependencies based on the specified tenant ID. Customize results by specifying page size for efficient pagination. Submit an empty body to get all dependencies associated with the configurations.
         * @summary List Dependencies
         * @param {string} tenantId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListDependenciesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorListDependencies(tenantId: string, pageSize: number, body: ProductConfiguratorListDependenciesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependencyListDependenciesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorListDependencies(tenantId, pageSize, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DependencyApi.productConfiguratorListDependencies']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modify an existing dependency by specifying the tenant and dependency IDs. Utilize a PUT request with updated dependency details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Dependency
         * @param {string} tenantId 
         * @param {string} dependencyId 
         * @param {ProductConfiguratorUpdateDependencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorUpdateDependency(tenantId: string, dependencyId: string, body: ProductConfiguratorUpdateDependencyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratordependencyEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorUpdateDependency(tenantId, dependencyId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DependencyApi.productConfiguratorUpdateDependency']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DependencyApi - factory interface
 * @export
 */
export const DependencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DependencyApiFp(configuration)
    return {
        /**
         * Establish a new dependency for an existing step by specifying the tenant and step IDs. Utilize a POST request with the required dependency details in the body to seamlessly enhance the configuration logic of your product.
         * @summary Create Dependency
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorCreateDependencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateDependency(tenantId: string, stepId: string, body: ProductConfiguratorCreateDependencyRequest, options?: any): AxiosPromise<ProductconfiguratordependencyEntity> {
            return localVarFp.productConfiguratorCreateDependency(tenantId, stepId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a specific dependency by specifying the tenant and dependency IDs. Ensure precision in dependency management with a straightforward DELETE request, simplifying the elimination of unwanted configuration logic.
         * @summary Delete Dependency
         * @param {string} tenantId 
         * @param {string} dependencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteDependency(tenantId: string, dependencyId: string, options?: any): AxiosPromise<object> {
            return localVarFp.productConfiguratorDeleteDependency(tenantId, dependencyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of dependencies based on the specified tenant ID. Customize results by specifying page size for efficient pagination. Submit an empty body to get all dependencies associated with the configurations.
         * @summary List Dependencies
         * @param {string} tenantId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListDependenciesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListDependencies(tenantId: string, pageSize: number, body: ProductConfiguratorListDependenciesRequest, options?: any): AxiosPromise<DependencyListDependenciesResponse> {
            return localVarFp.productConfiguratorListDependencies(tenantId, pageSize, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing dependency by specifying the tenant and dependency IDs. Utilize a PUT request with updated dependency details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Dependency
         * @param {string} tenantId 
         * @param {string} dependencyId 
         * @param {ProductConfiguratorUpdateDependencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateDependency(tenantId: string, dependencyId: string, body: ProductConfiguratorUpdateDependencyRequest, options?: any): AxiosPromise<ProductconfiguratordependencyEntity> {
            return localVarFp.productConfiguratorUpdateDependency(tenantId, dependencyId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DependencyApi - object-oriented interface
 * @export
 * @class DependencyApi
 * @extends {BaseAPI}
 */
export class DependencyApi extends BaseAPI {
    /**
     * Establish a new dependency for an existing step by specifying the tenant and step IDs. Utilize a POST request with the required dependency details in the body to seamlessly enhance the configuration logic of your product.
     * @summary Create Dependency
     * @param {string} tenantId 
     * @param {string} stepId 
     * @param {ProductConfiguratorCreateDependencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyApi
     */
    public productConfiguratorCreateDependency(tenantId: string, stepId: string, body: ProductConfiguratorCreateDependencyRequest, options?: RawAxiosRequestConfig) {
        return DependencyApiFp(this.configuration).productConfiguratorCreateDependency(tenantId, stepId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a specific dependency by specifying the tenant and dependency IDs. Ensure precision in dependency management with a straightforward DELETE request, simplifying the elimination of unwanted configuration logic.
     * @summary Delete Dependency
     * @param {string} tenantId 
     * @param {string} dependencyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyApi
     */
    public productConfiguratorDeleteDependency(tenantId: string, dependencyId: string, options?: RawAxiosRequestConfig) {
        return DependencyApiFp(this.configuration).productConfiguratorDeleteDependency(tenantId, dependencyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of dependencies based on the specified tenant ID. Customize results by specifying page size for efficient pagination. Submit an empty body to get all dependencies associated with the configurations.
     * @summary List Dependencies
     * @param {string} tenantId 
     * @param {number} pageSize 
     * @param {ProductConfiguratorListDependenciesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyApi
     */
    public productConfiguratorListDependencies(tenantId: string, pageSize: number, body: ProductConfiguratorListDependenciesRequest, options?: RawAxiosRequestConfig) {
        return DependencyApiFp(this.configuration).productConfiguratorListDependencies(tenantId, pageSize, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify an existing dependency by specifying the tenant and dependency IDs. Utilize a PUT request with updated dependency details in the body for seamless customization and fine-tuning of your product configurations.
     * @summary Update Dependency
     * @param {string} tenantId 
     * @param {string} dependencyId 
     * @param {ProductConfiguratorUpdateDependencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyApi
     */
    public productConfiguratorUpdateDependency(tenantId: string, dependencyId: string, body: ProductConfiguratorUpdateDependencyRequest, options?: RawAxiosRequestConfig) {
        return DependencyApiFp(this.configuration).productConfiguratorUpdateDependency(tenantId, dependencyId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MatrixApi - axios parameter creator
 * @export
 */
export const MatrixApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
         * @summary Create Matrix
         * @param {string} tenantId 
         * @param {ProductConfiguratorCreateMatrixRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateMatrix: async (tenantId: string, body: ProductConfiguratorCreateMatrixRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCreateMatrix', 'tenantId', tenantId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCreateMatrix', 'body', body)
            const localVarPath = `/v1/{tenantId}/matrix/create`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
         * @summary Delete Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteMatrix: async (tenantId: string, matrixId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorDeleteMatrix', 'tenantId', tenantId)
            // verify required parameter 'matrixId' is not null or undefined
            assertParamExists('productConfiguratorDeleteMatrix', 'matrixId', matrixId)
            const localVarPath = `/v1/{tenantId}/matrix/{matrixId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"matrixId"}}`, encodeURIComponent(String(matrixId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
         * @summary Get Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetMatrix: async (tenantId: string, matrixId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorGetMatrix', 'tenantId', tenantId)
            // verify required parameter 'matrixId' is not null or undefined
            assertParamExists('productConfiguratorGetMatrix', 'matrixId', matrixId)
            const localVarPath = `/v1/{tenantId}/matrix/{matrixId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"matrixId"}}`, encodeURIComponent(String(matrixId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
         * @summary List Matrices
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListMatricesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListMatrices: async (tenantId: string, configuratorId: string, pageSize: string, body: ProductConfiguratorListMatricesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorListMatrices', 'tenantId', tenantId)
            // verify required parameter 'configuratorId' is not null or undefined
            assertParamExists('productConfiguratorListMatrices', 'configuratorId', configuratorId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('productConfiguratorListMatrices', 'pageSize', pageSize)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorListMatrices', 'body', body)
            const localVarPath = `/v1/{tenantId}/configurator/{configuratorId}/page-size/{pageSize}/matrices`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"configuratorId"}}`, encodeURIComponent(String(configuratorId)))
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
         * @summary Remove Pricelist from Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {string} pricelistGrn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorRemovePricelistFromMatrix: async (tenantId: string, matrixId: string, pricelistGrn: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorRemovePricelistFromMatrix', 'tenantId', tenantId)
            // verify required parameter 'matrixId' is not null or undefined
            assertParamExists('productConfiguratorRemovePricelistFromMatrix', 'matrixId', matrixId)
            // verify required parameter 'pricelistGrn' is not null or undefined
            assertParamExists('productConfiguratorRemovePricelistFromMatrix', 'pricelistGrn', pricelistGrn)
            const localVarPath = `/v1/{tenantId}/matrix/{matrixId}/pricelist/{pricelistGrn}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"matrixId"}}`, encodeURIComponent(String(matrixId)))
                .replace(`{${"pricelistGrn"}}`, encodeURIComponent(String(pricelistGrn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
         * @summary Update Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {ProductConfiguratorUpdateMatrixRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateMatrix: async (tenantId: string, matrixId: string, body: ProductConfiguratorUpdateMatrixRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorUpdateMatrix', 'tenantId', tenantId)
            // verify required parameter 'matrixId' is not null or undefined
            assertParamExists('productConfiguratorUpdateMatrix', 'matrixId', matrixId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorUpdateMatrix', 'body', body)
            const localVarPath = `/v1/{tenantId}/matrix/{matrixId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"matrixId"}}`, encodeURIComponent(String(matrixId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatrixApi - functional programming interface
 * @export
 */
export const MatrixApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatrixApiAxiosParamCreator(configuration)
    return {
        /**
         * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
         * @summary Create Matrix
         * @param {string} tenantId 
         * @param {ProductConfiguratorCreateMatrixRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCreateMatrix(tenantId: string, body: ProductConfiguratorCreateMatrixRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratormatrixEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCreateMatrix(tenantId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MatrixApi.productConfiguratorCreateMatrix']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
         * @summary Delete Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorDeleteMatrix(tenantId: string, matrixId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorDeleteMatrix(tenantId, matrixId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MatrixApi.productConfiguratorDeleteMatrix']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
         * @summary Get Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorGetMatrix(tenantId: string, matrixId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratormatrixEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorGetMatrix(tenantId, matrixId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MatrixApi.productConfiguratorGetMatrix']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
         * @summary List Matrices
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListMatricesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorListMatrices(tenantId: string, configuratorId: string, pageSize: string, body: ProductConfiguratorListMatricesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatrixListMatricesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorListMatrices(tenantId, configuratorId, pageSize, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MatrixApi.productConfiguratorListMatrices']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
         * @summary Remove Pricelist from Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {string} pricelistGrn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorRemovePricelistFromMatrix(tenantId: string, matrixId: string, pricelistGrn: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratormatrixEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorRemovePricelistFromMatrix(tenantId, matrixId, pricelistGrn, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MatrixApi.productConfiguratorRemovePricelistFromMatrix']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
         * @summary Update Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {ProductConfiguratorUpdateMatrixRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorUpdateMatrix(tenantId: string, matrixId: string, body: ProductConfiguratorUpdateMatrixRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratormatrixEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorUpdateMatrix(tenantId, matrixId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MatrixApi.productConfiguratorUpdateMatrix']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MatrixApi - factory interface
 * @export
 */
export const MatrixApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatrixApiFp(configuration)
    return {
        /**
         * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
         * @summary Create Matrix
         * @param {string} tenantId 
         * @param {ProductConfiguratorCreateMatrixRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateMatrix(tenantId: string, body: ProductConfiguratorCreateMatrixRequest, options?: any): AxiosPromise<ProductconfiguratormatrixEntity> {
            return localVarFp.productConfiguratorCreateMatrix(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
         * @summary Delete Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteMatrix(tenantId: string, matrixId: string, options?: any): AxiosPromise<object> {
            return localVarFp.productConfiguratorDeleteMatrix(tenantId, matrixId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
         * @summary Get Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetMatrix(tenantId: string, matrixId: string, options?: any): AxiosPromise<ProductconfiguratormatrixEntity> {
            return localVarFp.productConfiguratorGetMatrix(tenantId, matrixId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
         * @summary List Matrices
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListMatricesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListMatrices(tenantId: string, configuratorId: string, pageSize: string, body: ProductConfiguratorListMatricesRequest, options?: any): AxiosPromise<MatrixListMatricesResponse> {
            return localVarFp.productConfiguratorListMatrices(tenantId, configuratorId, pageSize, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
         * @summary Remove Pricelist from Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {string} pricelistGrn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorRemovePricelistFromMatrix(tenantId: string, matrixId: string, pricelistGrn: string, options?: any): AxiosPromise<ProductconfiguratormatrixEntity> {
            return localVarFp.productConfiguratorRemovePricelistFromMatrix(tenantId, matrixId, pricelistGrn, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
         * @summary Update Matrix
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {ProductConfiguratorUpdateMatrixRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateMatrix(tenantId: string, matrixId: string, body: ProductConfiguratorUpdateMatrixRequest, options?: any): AxiosPromise<ProductconfiguratormatrixEntity> {
            return localVarFp.productConfiguratorUpdateMatrix(tenantId, matrixId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatrixApi - object-oriented interface
 * @export
 * @class MatrixApi
 * @extends {BaseAPI}
 */
export class MatrixApi extends BaseAPI {
    /**
     * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
     * @summary Create Matrix
     * @param {string} tenantId 
     * @param {ProductConfiguratorCreateMatrixRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatrixApi
     */
    public productConfiguratorCreateMatrix(tenantId: string, body: ProductConfiguratorCreateMatrixRequest, options?: RawAxiosRequestConfig) {
        return MatrixApiFp(this.configuration).productConfiguratorCreateMatrix(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
     * @summary Delete Matrix
     * @param {string} tenantId 
     * @param {string} matrixId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatrixApi
     */
    public productConfiguratorDeleteMatrix(tenantId: string, matrixId: string, options?: RawAxiosRequestConfig) {
        return MatrixApiFp(this.configuration).productConfiguratorDeleteMatrix(tenantId, matrixId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
     * @summary Get Matrix
     * @param {string} tenantId 
     * @param {string} matrixId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatrixApi
     */
    public productConfiguratorGetMatrix(tenantId: string, matrixId: string, options?: RawAxiosRequestConfig) {
        return MatrixApiFp(this.configuration).productConfiguratorGetMatrix(tenantId, matrixId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
     * @summary List Matrices
     * @param {string} tenantId 
     * @param {string} configuratorId 
     * @param {string} pageSize 
     * @param {ProductConfiguratorListMatricesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatrixApi
     */
    public productConfiguratorListMatrices(tenantId: string, configuratorId: string, pageSize: string, body: ProductConfiguratorListMatricesRequest, options?: RawAxiosRequestConfig) {
        return MatrixApiFp(this.configuration).productConfiguratorListMatrices(tenantId, configuratorId, pageSize, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
     * @summary Remove Pricelist from Matrix
     * @param {string} tenantId 
     * @param {string} matrixId 
     * @param {string} pricelistGrn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatrixApi
     */
    public productConfiguratorRemovePricelistFromMatrix(tenantId: string, matrixId: string, pricelistGrn: string, options?: RawAxiosRequestConfig) {
        return MatrixApiFp(this.configuration).productConfiguratorRemovePricelistFromMatrix(tenantId, matrixId, pricelistGrn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
     * @summary Update Matrix
     * @param {string} tenantId 
     * @param {string} matrixId 
     * @param {ProductConfiguratorUpdateMatrixRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatrixApi
     */
    public productConfiguratorUpdateMatrix(tenantId: string, matrixId: string, body: ProductConfiguratorUpdateMatrixRequest, options?: RawAxiosRequestConfig) {
        return MatrixApiFp(this.configuration).productConfiguratorUpdateMatrix(tenantId, matrixId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OptionApi - axios parameter creator
 * @export
 */
export const OptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add multiple options to an existing step simultaneously. Submit a POST request with the necessary option details in the body to efficiently expand the configuration possibilities in bulk. Streamline large-scale option management effortlessly.
         * @summary Bulk Create Options
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorBulkCreateOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkCreateOptions: async (tenantId: string, stepId: string, body: ProductConfiguratorBulkCreateOptionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorBulkCreateOptions', 'tenantId', tenantId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('productConfiguratorBulkCreateOptions', 'stepId', stepId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorBulkCreateOptions', 'body', body)
            const localVarPath = `/v1/{tenantId}/step/{stepId}/option/create/bulk`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Efficiently remove multiple options from configurations using a bulk delete operation. Specify the tenant ID and submit a POST request with the list of option IDs in the body for streamlined option management.
         * @summary Bulk Delete Options
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkDeleteOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkDeleteOptions: async (tenantId: string, body: ProductConfiguratorBulkDeleteOptionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorBulkDeleteOptions', 'tenantId', tenantId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorBulkDeleteOptions', 'body', body)
            const localVarPath = `/v1/{tenantId}/option/delete/bulk`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Effortlessly update multiple options. Specify the tenant ID and submit a PUT request with the updated option details in the body. Streamline the customization of a multitude of options in one go.
         * @summary Bulk Update Options
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkUpdateOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkUpdateOptions: async (tenantId: string, body: ProductConfiguratorBulkUpdateOptionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorBulkUpdateOptions', 'tenantId', tenantId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorBulkUpdateOptions', 'body', body)
            const localVarPath = `/v1/{tenantId}/option/bulk`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicate an existing option from the source to a specified tenant. Utilize a POST request with an empty body to initiate the copy process, creating a new option based on the source configuration. Streamline option replication effortlessly.
         * @summary Copy Option
         * @param {string} tenantId 
         * @param {string} sourceOptionId 
         * @param {ProductConfiguratorCopyOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCopyOption: async (tenantId: string, sourceOptionId: string, body: ProductConfiguratorCopyOptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCopyOption', 'tenantId', tenantId)
            // verify required parameter 'sourceOptionId' is not null or undefined
            assertParamExists('productConfiguratorCopyOption', 'sourceOptionId', sourceOptionId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCopyOption', 'body', body)
            const localVarPath = `/v1/{tenantId}/option/{sourceOptionId}/copy`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"sourceOptionId"}}`, encodeURIComponent(String(sourceOptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Integrate a new option into an existing step by specifying the tenant and step IDs. Use a POST request with the required option details in the body for seamless customization and expansion of product configurations.
         * @summary Create Option
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorCreateOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateOption: async (tenantId: string, stepId: string, body: ProductConfiguratorCreateOptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCreateOption', 'tenantId', tenantId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('productConfiguratorCreateOption', 'stepId', stepId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCreateOption', 'body', body)
            const localVarPath = `/v1/{tenantId}/step/{stepId}/option/create`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a specific option by specifying the tenant and option IDs. Ensure precision in option management with a straightforward DELETE request, simplifying the elimination of unwanted configuration choices.
         * @summary Delete Option
         * @param {string} tenantId 
         * @param {string} optionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteOption: async (tenantId: string, optionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorDeleteOption', 'tenantId', tenantId)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('productConfiguratorDeleteOption', 'optionId', optionId)
            const localVarPath = `/v1/{tenantId}/option/{optionId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of options for a specific step based on tenant and step IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all options associated with the step.
         * @summary List Options
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListOptions: async (tenantId: string, stepId: string, pageSize: number, body: ProductConfiguratorListPropertiesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorListOptions', 'tenantId', tenantId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('productConfiguratorListOptions', 'stepId', stepId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('productConfiguratorListOptions', 'pageSize', pageSize)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorListOptions', 'body', body)
            const localVarPath = `/v1/{tenantId}/step/{stepId}/page-size/{pageSize}/options`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)))
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing option by specifying the tenant and option IDs. Utilize a PUT request with updated option details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Option
         * @param {string} tenantId 
         * @param {string} optionId 
         * @param {ProductConfiguratorUpdateOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateOption: async (tenantId: string, optionId: string, body: ProductConfiguratorUpdateOptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorUpdateOption', 'tenantId', tenantId)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('productConfiguratorUpdateOption', 'optionId', optionId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorUpdateOption', 'body', body)
            const localVarPath = `/v1/{tenantId}/option/{optionId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OptionApi - functional programming interface
 * @export
 */
export const OptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Add multiple options to an existing step simultaneously. Submit a POST request with the necessary option details in the body to efficiently expand the configuration possibilities in bulk. Streamline large-scale option management effortlessly.
         * @summary Bulk Create Options
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorBulkCreateOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorBulkCreateOptions(tenantId: string, stepId: string, body: ProductConfiguratorBulkCreateOptionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratoroptionBulkCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorBulkCreateOptions(tenantId, stepId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OptionApi.productConfiguratorBulkCreateOptions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Efficiently remove multiple options from configurations using a bulk delete operation. Specify the tenant ID and submit a POST request with the list of option IDs in the body for streamlined option management.
         * @summary Bulk Delete Options
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkDeleteOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorBulkDeleteOptions(tenantId: string, body: ProductConfiguratorBulkDeleteOptionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorBulkDeleteOptions(tenantId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OptionApi.productConfiguratorBulkDeleteOptions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Effortlessly update multiple options. Specify the tenant ID and submit a PUT request with the updated option details in the body. Streamline the customization of a multitude of options in one go.
         * @summary Bulk Update Options
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkUpdateOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorBulkUpdateOptions(tenantId: string, body: ProductConfiguratorBulkUpdateOptionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratoroptionBulkUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorBulkUpdateOptions(tenantId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OptionApi.productConfiguratorBulkUpdateOptions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Duplicate an existing option from the source to a specified tenant. Utilize a POST request with an empty body to initiate the copy process, creating a new option based on the source configuration. Streamline option replication effortlessly.
         * @summary Copy Option
         * @param {string} tenantId 
         * @param {string} sourceOptionId 
         * @param {ProductConfiguratorCopyOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCopyOption(tenantId: string, sourceOptionId: string, body: ProductConfiguratorCopyOptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratoroptionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCopyOption(tenantId, sourceOptionId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OptionApi.productConfiguratorCopyOption']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Integrate a new option into an existing step by specifying the tenant and step IDs. Use a POST request with the required option details in the body for seamless customization and expansion of product configurations.
         * @summary Create Option
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorCreateOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCreateOption(tenantId: string, stepId: string, body: ProductConfiguratorCreateOptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratoroptionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCreateOption(tenantId, stepId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OptionApi.productConfiguratorCreateOption']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove a specific option by specifying the tenant and option IDs. Ensure precision in option management with a straightforward DELETE request, simplifying the elimination of unwanted configuration choices.
         * @summary Delete Option
         * @param {string} tenantId 
         * @param {string} optionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorDeleteOption(tenantId: string, optionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorDeleteOption(tenantId, optionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OptionApi.productConfiguratorDeleteOption']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a list of options for a specific step based on tenant and step IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all options associated with the step.
         * @summary List Options
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorListOptions(tenantId: string, stepId: string, pageSize: number, body: ProductConfiguratorListPropertiesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionListOptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorListOptions(tenantId, stepId, pageSize, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OptionApi.productConfiguratorListOptions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modify an existing option by specifying the tenant and option IDs. Utilize a PUT request with updated option details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Option
         * @param {string} tenantId 
         * @param {string} optionId 
         * @param {ProductConfiguratorUpdateOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorUpdateOption(tenantId: string, optionId: string, body: ProductConfiguratorUpdateOptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratoroptionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorUpdateOption(tenantId, optionId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OptionApi.productConfiguratorUpdateOption']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OptionApi - factory interface
 * @export
 */
export const OptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OptionApiFp(configuration)
    return {
        /**
         * Add multiple options to an existing step simultaneously. Submit a POST request with the necessary option details in the body to efficiently expand the configuration possibilities in bulk. Streamline large-scale option management effortlessly.
         * @summary Bulk Create Options
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorBulkCreateOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkCreateOptions(tenantId: string, stepId: string, body: ProductConfiguratorBulkCreateOptionsRequest, options?: any): AxiosPromise<ProductconfiguratoroptionBulkCreateResponse> {
            return localVarFp.productConfiguratorBulkCreateOptions(tenantId, stepId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Efficiently remove multiple options from configurations using a bulk delete operation. Specify the tenant ID and submit a POST request with the list of option IDs in the body for streamlined option management.
         * @summary Bulk Delete Options
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkDeleteOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkDeleteOptions(tenantId: string, body: ProductConfiguratorBulkDeleteOptionsRequest, options?: any): AxiosPromise<object> {
            return localVarFp.productConfiguratorBulkDeleteOptions(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Effortlessly update multiple options. Specify the tenant ID and submit a PUT request with the updated option details in the body. Streamline the customization of a multitude of options in one go.
         * @summary Bulk Update Options
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkUpdateOptionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkUpdateOptions(tenantId: string, body: ProductConfiguratorBulkUpdateOptionsRequest, options?: any): AxiosPromise<ProductconfiguratoroptionBulkUpdateResponse> {
            return localVarFp.productConfiguratorBulkUpdateOptions(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicate an existing option from the source to a specified tenant. Utilize a POST request with an empty body to initiate the copy process, creating a new option based on the source configuration. Streamline option replication effortlessly.
         * @summary Copy Option
         * @param {string} tenantId 
         * @param {string} sourceOptionId 
         * @param {ProductConfiguratorCopyOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCopyOption(tenantId: string, sourceOptionId: string, body: ProductConfiguratorCopyOptionRequest, options?: any): AxiosPromise<ProductconfiguratoroptionEntity> {
            return localVarFp.productConfiguratorCopyOption(tenantId, sourceOptionId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Integrate a new option into an existing step by specifying the tenant and step IDs. Use a POST request with the required option details in the body for seamless customization and expansion of product configurations.
         * @summary Create Option
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorCreateOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateOption(tenantId: string, stepId: string, body: ProductConfiguratorCreateOptionRequest, options?: any): AxiosPromise<ProductconfiguratoroptionEntity> {
            return localVarFp.productConfiguratorCreateOption(tenantId, stepId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a specific option by specifying the tenant and option IDs. Ensure precision in option management with a straightforward DELETE request, simplifying the elimination of unwanted configuration choices.
         * @summary Delete Option
         * @param {string} tenantId 
         * @param {string} optionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteOption(tenantId: string, optionId: string, options?: any): AxiosPromise<object> {
            return localVarFp.productConfiguratorDeleteOption(tenantId, optionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of options for a specific step based on tenant and step IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all options associated with the step.
         * @summary List Options
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {number} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListOptions(tenantId: string, stepId: string, pageSize: number, body: ProductConfiguratorListPropertiesRequest, options?: any): AxiosPromise<OptionListOptionsResponse> {
            return localVarFp.productConfiguratorListOptions(tenantId, stepId, pageSize, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing option by specifying the tenant and option IDs. Utilize a PUT request with updated option details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Option
         * @param {string} tenantId 
         * @param {string} optionId 
         * @param {ProductConfiguratorUpdateOptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateOption(tenantId: string, optionId: string, body: ProductConfiguratorUpdateOptionRequest, options?: any): AxiosPromise<ProductconfiguratoroptionEntity> {
            return localVarFp.productConfiguratorUpdateOption(tenantId, optionId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OptionApi - object-oriented interface
 * @export
 * @class OptionApi
 * @extends {BaseAPI}
 */
export class OptionApi extends BaseAPI {
    /**
     * Add multiple options to an existing step simultaneously. Submit a POST request with the necessary option details in the body to efficiently expand the configuration possibilities in bulk. Streamline large-scale option management effortlessly.
     * @summary Bulk Create Options
     * @param {string} tenantId 
     * @param {string} stepId 
     * @param {ProductConfiguratorBulkCreateOptionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public productConfiguratorBulkCreateOptions(tenantId: string, stepId: string, body: ProductConfiguratorBulkCreateOptionsRequest, options?: RawAxiosRequestConfig) {
        return OptionApiFp(this.configuration).productConfiguratorBulkCreateOptions(tenantId, stepId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Efficiently remove multiple options from configurations using a bulk delete operation. Specify the tenant ID and submit a POST request with the list of option IDs in the body for streamlined option management.
     * @summary Bulk Delete Options
     * @param {string} tenantId 
     * @param {ProductConfiguratorBulkDeleteOptionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public productConfiguratorBulkDeleteOptions(tenantId: string, body: ProductConfiguratorBulkDeleteOptionsRequest, options?: RawAxiosRequestConfig) {
        return OptionApiFp(this.configuration).productConfiguratorBulkDeleteOptions(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Effortlessly update multiple options. Specify the tenant ID and submit a PUT request with the updated option details in the body. Streamline the customization of a multitude of options in one go.
     * @summary Bulk Update Options
     * @param {string} tenantId 
     * @param {ProductConfiguratorBulkUpdateOptionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public productConfiguratorBulkUpdateOptions(tenantId: string, body: ProductConfiguratorBulkUpdateOptionsRequest, options?: RawAxiosRequestConfig) {
        return OptionApiFp(this.configuration).productConfiguratorBulkUpdateOptions(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Duplicate an existing option from the source to a specified tenant. Utilize a POST request with an empty body to initiate the copy process, creating a new option based on the source configuration. Streamline option replication effortlessly.
     * @summary Copy Option
     * @param {string} tenantId 
     * @param {string} sourceOptionId 
     * @param {ProductConfiguratorCopyOptionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public productConfiguratorCopyOption(tenantId: string, sourceOptionId: string, body: ProductConfiguratorCopyOptionRequest, options?: RawAxiosRequestConfig) {
        return OptionApiFp(this.configuration).productConfiguratorCopyOption(tenantId, sourceOptionId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Integrate a new option into an existing step by specifying the tenant and step IDs. Use a POST request with the required option details in the body for seamless customization and expansion of product configurations.
     * @summary Create Option
     * @param {string} tenantId 
     * @param {string} stepId 
     * @param {ProductConfiguratorCreateOptionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public productConfiguratorCreateOption(tenantId: string, stepId: string, body: ProductConfiguratorCreateOptionRequest, options?: RawAxiosRequestConfig) {
        return OptionApiFp(this.configuration).productConfiguratorCreateOption(tenantId, stepId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a specific option by specifying the tenant and option IDs. Ensure precision in option management with a straightforward DELETE request, simplifying the elimination of unwanted configuration choices.
     * @summary Delete Option
     * @param {string} tenantId 
     * @param {string} optionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public productConfiguratorDeleteOption(tenantId: string, optionId: string, options?: RawAxiosRequestConfig) {
        return OptionApiFp(this.configuration).productConfiguratorDeleteOption(tenantId, optionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of options for a specific step based on tenant and step IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all options associated with the step.
     * @summary List Options
     * @param {string} tenantId 
     * @param {string} stepId 
     * @param {number} pageSize 
     * @param {ProductConfiguratorListPropertiesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public productConfiguratorListOptions(tenantId: string, stepId: string, pageSize: number, body: ProductConfiguratorListPropertiesRequest, options?: RawAxiosRequestConfig) {
        return OptionApiFp(this.configuration).productConfiguratorListOptions(tenantId, stepId, pageSize, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify an existing option by specifying the tenant and option IDs. Utilize a PUT request with updated option details in the body for seamless customization and fine-tuning of your product configurations.
     * @summary Update Option
     * @param {string} tenantId 
     * @param {string} optionId 
     * @param {ProductConfiguratorUpdateOptionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public productConfiguratorUpdateOption(tenantId: string, optionId: string, body: ProductConfiguratorUpdateOptionRequest, options?: RawAxiosRequestConfig) {
        return OptionApiFp(this.configuration).productConfiguratorUpdateOption(tenantId, optionId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductConfiguratorApi - axios parameter creator
 * @export
 */
export const ProductConfiguratorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} tenantId 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetProperty: async (tenantId: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorGetProperty', 'tenantId', tenantId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('productConfiguratorGetProperty', 'propertyId', propertyId)
            const localVarPath = `/v1/{tenantId}/property/{propertyId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListPropertiesByConfigurationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListPropertiesByConfiguration: async (tenantId: string, configuratorId: string, pageSize: string, body: ProductConfiguratorListPropertiesByConfigurationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorListPropertiesByConfiguration', 'tenantId', tenantId)
            // verify required parameter 'configuratorId' is not null or undefined
            assertParamExists('productConfiguratorListPropertiesByConfiguration', 'configuratorId', configuratorId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('productConfiguratorListPropertiesByConfiguration', 'pageSize', pageSize)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorListPropertiesByConfiguration', 'body', body)
            const localVarPath = `/v1/{tenantId}/configurator/{configuratorId}/page-size/{pageSize}/properties`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"configuratorId"}}`, encodeURIComponent(String(configuratorId)))
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductConfiguratorApi - functional programming interface
 * @export
 */
export const ProductConfiguratorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductConfiguratorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} tenantId 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorGetProperty(tenantId: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorpropertyEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorGetProperty(tenantId, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductConfiguratorApi.productConfiguratorGetProperty']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListPropertiesByConfigurationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorListPropertiesByConfiguration(tenantId: string, configuratorId: string, pageSize: string, body: ProductConfiguratorListPropertiesByConfigurationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyListPropertiesByConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorListPropertiesByConfiguration(tenantId, configuratorId, pageSize, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductConfiguratorApi.productConfiguratorListPropertiesByConfiguration']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProductConfiguratorApi - factory interface
 * @export
 */
export const ProductConfiguratorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductConfiguratorApiFp(configuration)
    return {
        /**
         * 
         * @param {string} tenantId 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorGetProperty(tenantId: string, propertyId: string, options?: any): AxiosPromise<ProductconfiguratorpropertyEntity> {
            return localVarFp.productConfiguratorGetProperty(tenantId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListPropertiesByConfigurationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListPropertiesByConfiguration(tenantId: string, configuratorId: string, pageSize: string, body: ProductConfiguratorListPropertiesByConfigurationRequest, options?: any): AxiosPromise<PropertyListPropertiesByConfigurationResponse> {
            return localVarFp.productConfiguratorListPropertiesByConfiguration(tenantId, configuratorId, pageSize, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductConfiguratorApi - object-oriented interface
 * @export
 * @class ProductConfiguratorApi
 * @extends {BaseAPI}
 */
export class ProductConfiguratorApi extends BaseAPI {
    /**
     * 
     * @param {string} tenantId 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductConfiguratorApi
     */
    public productConfiguratorGetProperty(tenantId: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return ProductConfiguratorApiFp(this.configuration).productConfiguratorGetProperty(tenantId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId 
     * @param {string} configuratorId 
     * @param {string} pageSize 
     * @param {ProductConfiguratorListPropertiesByConfigurationRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductConfiguratorApi
     */
    public productConfiguratorListPropertiesByConfiguration(tenantId: string, configuratorId: string, pageSize: string, body: ProductConfiguratorListPropertiesByConfigurationRequest, options?: RawAxiosRequestConfig) {
        return ProductConfiguratorApiFp(this.configuration).productConfiguratorListPropertiesByConfiguration(tenantId, configuratorId, pageSize, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyApi - axios parameter creator
 * @export
 */
export const PropertyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Efficiently add multiple properties to configurations with a bulk create operation. Specify the tenant ID and submit a POST request with the necessary property details in the body for streamlined property management.
         * @summary Bulk Create Properties
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkCreatePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkCreateProperties: async (tenantId: string, body: ProductConfiguratorBulkCreatePropertiesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorBulkCreateProperties', 'tenantId', tenantId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorBulkCreateProperties', 'body', body)
            const localVarPath = `/v1/{tenantId}/property/create/bulk`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Effortlessly update multiple properties. Specify the tenant ID and submit a PUT request with the updated property details in the body. Streamline the customization of a multitude of properties in one go.
         * @summary Bulk Update Properties
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkUpdatePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkUpdateProperties: async (tenantId: string, body: ProductConfiguratorBulkUpdatePropertiesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorBulkUpdateProperties', 'tenantId', tenantId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorBulkUpdateProperties', 'body', body)
            const localVarPath = `/v1/{tenantId}/properties/bulk`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Integrate a new property into configurations by specifying the tenant ID. Use a POST request with the required property details in the body for seamless customization and expansion of product configurations.
         * @summary Create Property
         * @param {string} tenantId 
         * @param {ProductConfiguratorCreatePropertyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateProperty: async (tenantId: string, body: ProductConfiguratorCreatePropertyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCreateProperty', 'tenantId', tenantId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCreateProperty', 'body', body)
            const localVarPath = `/v1/{tenantId}/property/create`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of properties for a specific matrix based on tenant and matrix IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all properties associated with the matrix.
         * @summary List Properties
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListProperties: async (tenantId: string, matrixId: string, pageSize: string, body: ProductConfiguratorListPropertiesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorListProperties', 'tenantId', tenantId)
            // verify required parameter 'matrixId' is not null or undefined
            assertParamExists('productConfiguratorListProperties', 'matrixId', matrixId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('productConfiguratorListProperties', 'pageSize', pageSize)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorListProperties', 'body', body)
            const localVarPath = `/v1/{tenantId}/matrix/{matrixId}/page-size/{pageSize}/properties`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"matrixId"}}`, encodeURIComponent(String(matrixId)))
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing property by specifying the tenant and property IDs. Utilize a PUT request with updated property details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Property
         * @param {string} tenantId 
         * @param {string} propertyId 
         * @param {ProductConfiguratorUpdatePropertyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateProperty: async (tenantId: string, propertyId: string, body: ProductConfiguratorUpdatePropertyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorUpdateProperty', 'tenantId', tenantId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('productConfiguratorUpdateProperty', 'propertyId', propertyId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorUpdateProperty', 'body', body)
            const localVarPath = `/v1/{tenantId}/property/{propertyId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyApi - functional programming interface
 * @export
 */
export const PropertyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyApiAxiosParamCreator(configuration)
    return {
        /**
         * Efficiently add multiple properties to configurations with a bulk create operation. Specify the tenant ID and submit a POST request with the necessary property details in the body for streamlined property management.
         * @summary Bulk Create Properties
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkCreatePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorBulkCreateProperties(tenantId: string, body: ProductConfiguratorBulkCreatePropertiesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorpropertyBulkCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorBulkCreateProperties(tenantId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PropertyApi.productConfiguratorBulkCreateProperties']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Effortlessly update multiple properties. Specify the tenant ID and submit a PUT request with the updated property details in the body. Streamline the customization of a multitude of properties in one go.
         * @summary Bulk Update Properties
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkUpdatePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorBulkUpdateProperties(tenantId: string, body: ProductConfiguratorBulkUpdatePropertiesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorpropertyBulkUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorBulkUpdateProperties(tenantId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PropertyApi.productConfiguratorBulkUpdateProperties']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Integrate a new property into configurations by specifying the tenant ID. Use a POST request with the required property details in the body for seamless customization and expansion of product configurations.
         * @summary Create Property
         * @param {string} tenantId 
         * @param {ProductConfiguratorCreatePropertyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCreateProperty(tenantId: string, body: ProductConfiguratorCreatePropertyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorpropertyEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCreateProperty(tenantId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PropertyApi.productConfiguratorCreateProperty']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a list of properties for a specific matrix based on tenant and matrix IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all properties associated with the matrix.
         * @summary List Properties
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorListProperties(tenantId: string, matrixId: string, pageSize: string, body: ProductConfiguratorListPropertiesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyListPropertiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorListProperties(tenantId, matrixId, pageSize, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PropertyApi.productConfiguratorListProperties']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modify an existing property by specifying the tenant and property IDs. Utilize a PUT request with updated property details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Property
         * @param {string} tenantId 
         * @param {string} propertyId 
         * @param {ProductConfiguratorUpdatePropertyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorUpdateProperty(tenantId: string, propertyId: string, body: ProductConfiguratorUpdatePropertyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorpropertyEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorUpdateProperty(tenantId, propertyId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PropertyApi.productConfiguratorUpdateProperty']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PropertyApi - factory interface
 * @export
 */
export const PropertyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyApiFp(configuration)
    return {
        /**
         * Efficiently add multiple properties to configurations with a bulk create operation. Specify the tenant ID and submit a POST request with the necessary property details in the body for streamlined property management.
         * @summary Bulk Create Properties
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkCreatePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkCreateProperties(tenantId: string, body: ProductConfiguratorBulkCreatePropertiesRequest, options?: any): AxiosPromise<ProductconfiguratorpropertyBulkCreateResponse> {
            return localVarFp.productConfiguratorBulkCreateProperties(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Effortlessly update multiple properties. Specify the tenant ID and submit a PUT request with the updated property details in the body. Streamline the customization of a multitude of properties in one go.
         * @summary Bulk Update Properties
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkUpdatePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkUpdateProperties(tenantId: string, body: ProductConfiguratorBulkUpdatePropertiesRequest, options?: any): AxiosPromise<ProductconfiguratorpropertyBulkUpdateResponse> {
            return localVarFp.productConfiguratorBulkUpdateProperties(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Integrate a new property into configurations by specifying the tenant ID. Use a POST request with the required property details in the body for seamless customization and expansion of product configurations.
         * @summary Create Property
         * @param {string} tenantId 
         * @param {ProductConfiguratorCreatePropertyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateProperty(tenantId: string, body: ProductConfiguratorCreatePropertyRequest, options?: any): AxiosPromise<ProductconfiguratorpropertyEntity> {
            return localVarFp.productConfiguratorCreateProperty(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of properties for a specific matrix based on tenant and matrix IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all properties associated with the matrix.
         * @summary List Properties
         * @param {string} tenantId 
         * @param {string} matrixId 
         * @param {string} pageSize 
         * @param {ProductConfiguratorListPropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorListProperties(tenantId: string, matrixId: string, pageSize: string, body: ProductConfiguratorListPropertiesRequest, options?: any): AxiosPromise<PropertyListPropertiesResponse> {
            return localVarFp.productConfiguratorListProperties(tenantId, matrixId, pageSize, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing property by specifying the tenant and property IDs. Utilize a PUT request with updated property details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Property
         * @param {string} tenantId 
         * @param {string} propertyId 
         * @param {ProductConfiguratorUpdatePropertyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateProperty(tenantId: string, propertyId: string, body: ProductConfiguratorUpdatePropertyRequest, options?: any): AxiosPromise<ProductconfiguratorpropertyEntity> {
            return localVarFp.productConfiguratorUpdateProperty(tenantId, propertyId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyApi - object-oriented interface
 * @export
 * @class PropertyApi
 * @extends {BaseAPI}
 */
export class PropertyApi extends BaseAPI {
    /**
     * Efficiently add multiple properties to configurations with a bulk create operation. Specify the tenant ID and submit a POST request with the necessary property details in the body for streamlined property management.
     * @summary Bulk Create Properties
     * @param {string} tenantId 
     * @param {ProductConfiguratorBulkCreatePropertiesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public productConfiguratorBulkCreateProperties(tenantId: string, body: ProductConfiguratorBulkCreatePropertiesRequest, options?: RawAxiosRequestConfig) {
        return PropertyApiFp(this.configuration).productConfiguratorBulkCreateProperties(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Effortlessly update multiple properties. Specify the tenant ID and submit a PUT request with the updated property details in the body. Streamline the customization of a multitude of properties in one go.
     * @summary Bulk Update Properties
     * @param {string} tenantId 
     * @param {ProductConfiguratorBulkUpdatePropertiesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public productConfiguratorBulkUpdateProperties(tenantId: string, body: ProductConfiguratorBulkUpdatePropertiesRequest, options?: RawAxiosRequestConfig) {
        return PropertyApiFp(this.configuration).productConfiguratorBulkUpdateProperties(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Integrate a new property into configurations by specifying the tenant ID. Use a POST request with the required property details in the body for seamless customization and expansion of product configurations.
     * @summary Create Property
     * @param {string} tenantId 
     * @param {ProductConfiguratorCreatePropertyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public productConfiguratorCreateProperty(tenantId: string, body: ProductConfiguratorCreatePropertyRequest, options?: RawAxiosRequestConfig) {
        return PropertyApiFp(this.configuration).productConfiguratorCreateProperty(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of properties for a specific matrix based on tenant and matrix IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all properties associated with the matrix.
     * @summary List Properties
     * @param {string} tenantId 
     * @param {string} matrixId 
     * @param {string} pageSize 
     * @param {ProductConfiguratorListPropertiesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public productConfiguratorListProperties(tenantId: string, matrixId: string, pageSize: string, body: ProductConfiguratorListPropertiesRequest, options?: RawAxiosRequestConfig) {
        return PropertyApiFp(this.configuration).productConfiguratorListProperties(tenantId, matrixId, pageSize, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify an existing property by specifying the tenant and property IDs. Utilize a PUT request with updated property details in the body for seamless customization and fine-tuning of your product configurations.
     * @summary Update Property
     * @param {string} tenantId 
     * @param {string} propertyId 
     * @param {ProductConfiguratorUpdatePropertyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public productConfiguratorUpdateProperty(tenantId: string, propertyId: string, body: ProductConfiguratorUpdatePropertyRequest, options?: RawAxiosRequestConfig) {
        return PropertyApiFp(this.configuration).productConfiguratorUpdateProperty(tenantId, propertyId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StepApi - axios parameter creator
 * @export
 */
export const StepApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add multiple steps to an existing product configurator simultaneously. Submit a POST request with the necessary step details in the body to efficiently extend the configuration process in bulk. Simplify large-scale configuration management effortlessly.
         * @summary Bulk Create Steps
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorBulkCreateStepsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkCreateSteps: async (tenantId: string, configuratorId: string, body: ProductConfiguratorBulkCreateStepsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorBulkCreateSteps', 'tenantId', tenantId)
            // verify required parameter 'configuratorId' is not null or undefined
            assertParamExists('productConfiguratorBulkCreateSteps', 'configuratorId', configuratorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorBulkCreateSteps', 'body', body)
            const localVarPath = `/v1/{tenantId}/configurator/{configuratorId}/step/create/bulk`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"configuratorId"}}`, encodeURIComponent(String(configuratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Efficiently remove multiple steps from a product configurator using a bulk delete operation. Specify the tenant ID and submit a POST request with the list of step IDs in the body for streamlined configuration management.
         * @summary Bulk Delete Steps
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkDeleteStepsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkDeleteSteps: async (tenantId: string, body: ProductConfiguratorBulkDeleteStepsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorBulkDeleteSteps', 'tenantId', tenantId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorBulkDeleteSteps', 'body', body)
            const localVarPath = `/v1/{tenantId}/step/delete/bulk`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicate an existing step from the source to a specified tenant. Utilize a POST request with an empty body to initiate the copy process, creating a new step based on the source configuration. Streamline step replication effortlessly.
         * @summary Copy Step
         * @param {string} tenantId 
         * @param {string} sourceStepId 
         * @param {ProductConfiguratorCopyStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCopyStep: async (tenantId: string, sourceStepId: string, body: ProductConfiguratorCopyStepRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCopyStep', 'tenantId', tenantId)
            // verify required parameter 'sourceStepId' is not null or undefined
            assertParamExists('productConfiguratorCopyStep', 'sourceStepId', sourceStepId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCopyStep', 'body', body)
            const localVarPath = `/v1/{tenantId}/step/{sourceStepId}/copy`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"sourceStepId"}}`, encodeURIComponent(String(sourceStepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new step to an existing product configurator by specifying the tenant and configurator IDs. Utilize a POST request with the required step details in the body to seamlessly extend the configuration process.
         * @summary Create Step
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorCreateStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateStep: async (tenantId: string, configuratorId: string, body: ProductConfiguratorCreateStepRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorCreateStep', 'tenantId', tenantId)
            // verify required parameter 'configuratorId' is not null or undefined
            assertParamExists('productConfiguratorCreateStep', 'configuratorId', configuratorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorCreateStep', 'body', body)
            const localVarPath = `/v1/{tenantId}/configurator/{configuratorId}/step/create`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"configuratorId"}}`, encodeURIComponent(String(configuratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a step from a product configurator by specifying the tenant and step IDs. Ensure precision in configuration management with a straightforward DELETE request, simplifying the elimination of unwanted steps.
         * @summary Delete Step
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteStep: async (tenantId: string, stepId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorDeleteStep', 'tenantId', tenantId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('productConfiguratorDeleteStep', 'stepId', stepId)
            const localVarPath = `/v1/{tenantId}/step/{stepId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing step within a product configurator by specifying the tenant and step IDs. Utilize a PUT request with updated step details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Step
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorUpdateStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateStep: async (tenantId: string, stepId: string, body: ProductConfiguratorUpdateStepRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('productConfiguratorUpdateStep', 'tenantId', tenantId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('productConfiguratorUpdateStep', 'stepId', stepId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('productConfiguratorUpdateStep', 'body', body)
            const localVarPath = `/v1/{tenantId}/step/{stepId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)

            // authentication APIAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StepApi - functional programming interface
 * @export
 */
export const StepApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StepApiAxiosParamCreator(configuration)
    return {
        /**
         * Add multiple steps to an existing product configurator simultaneously. Submit a POST request with the necessary step details in the body to efficiently extend the configuration process in bulk. Simplify large-scale configuration management effortlessly.
         * @summary Bulk Create Steps
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorBulkCreateStepsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorBulkCreateSteps(tenantId: string, configuratorId: string, body: ProductConfiguratorBulkCreateStepsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorstepBulkCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorBulkCreateSteps(tenantId, configuratorId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StepApi.productConfiguratorBulkCreateSteps']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Efficiently remove multiple steps from a product configurator using a bulk delete operation. Specify the tenant ID and submit a POST request with the list of step IDs in the body for streamlined configuration management.
         * @summary Bulk Delete Steps
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkDeleteStepsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorBulkDeleteSteps(tenantId: string, body: ProductConfiguratorBulkDeleteStepsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorBulkDeleteSteps(tenantId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StepApi.productConfiguratorBulkDeleteSteps']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Duplicate an existing step from the source to a specified tenant. Utilize a POST request with an empty body to initiate the copy process, creating a new step based on the source configuration. Streamline step replication effortlessly.
         * @summary Copy Step
         * @param {string} tenantId 
         * @param {string} sourceStepId 
         * @param {ProductConfiguratorCopyStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCopyStep(tenantId: string, sourceStepId: string, body: ProductConfiguratorCopyStepRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorstepEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCopyStep(tenantId, sourceStepId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StepApi.productConfiguratorCopyStep']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Add a new step to an existing product configurator by specifying the tenant and configurator IDs. Utilize a POST request with the required step details in the body to seamlessly extend the configuration process.
         * @summary Create Step
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorCreateStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorCreateStep(tenantId: string, configuratorId: string, body: ProductConfiguratorCreateStepRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorstepEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorCreateStep(tenantId, configuratorId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StepApi.productConfiguratorCreateStep']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove a step from a product configurator by specifying the tenant and step IDs. Ensure precision in configuration management with a straightforward DELETE request, simplifying the elimination of unwanted steps.
         * @summary Delete Step
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorDeleteStep(tenantId: string, stepId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GooglerpcStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorDeleteStep(tenantId, stepId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StepApi.productConfiguratorDeleteStep']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modify an existing step within a product configurator by specifying the tenant and step IDs. Utilize a PUT request with updated step details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Step
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorUpdateStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productConfiguratorUpdateStep(tenantId: string, stepId: string, body: ProductConfiguratorUpdateStepRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductconfiguratorstepEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productConfiguratorUpdateStep(tenantId, stepId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StepApi.productConfiguratorUpdateStep']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StepApi - factory interface
 * @export
 */
export const StepApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StepApiFp(configuration)
    return {
        /**
         * Add multiple steps to an existing product configurator simultaneously. Submit a POST request with the necessary step details in the body to efficiently extend the configuration process in bulk. Simplify large-scale configuration management effortlessly.
         * @summary Bulk Create Steps
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorBulkCreateStepsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkCreateSteps(tenantId: string, configuratorId: string, body: ProductConfiguratorBulkCreateStepsRequest, options?: any): AxiosPromise<ProductconfiguratorstepBulkCreateResponse> {
            return localVarFp.productConfiguratorBulkCreateSteps(tenantId, configuratorId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Efficiently remove multiple steps from a product configurator using a bulk delete operation. Specify the tenant ID and submit a POST request with the list of step IDs in the body for streamlined configuration management.
         * @summary Bulk Delete Steps
         * @param {string} tenantId 
         * @param {ProductConfiguratorBulkDeleteStepsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorBulkDeleteSteps(tenantId: string, body: ProductConfiguratorBulkDeleteStepsRequest, options?: any): AxiosPromise<object> {
            return localVarFp.productConfiguratorBulkDeleteSteps(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicate an existing step from the source to a specified tenant. Utilize a POST request with an empty body to initiate the copy process, creating a new step based on the source configuration. Streamline step replication effortlessly.
         * @summary Copy Step
         * @param {string} tenantId 
         * @param {string} sourceStepId 
         * @param {ProductConfiguratorCopyStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCopyStep(tenantId: string, sourceStepId: string, body: ProductConfiguratorCopyStepRequest, options?: any): AxiosPromise<ProductconfiguratorstepEntity> {
            return localVarFp.productConfiguratorCopyStep(tenantId, sourceStepId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new step to an existing product configurator by specifying the tenant and configurator IDs. Utilize a POST request with the required step details in the body to seamlessly extend the configuration process.
         * @summary Create Step
         * @param {string} tenantId 
         * @param {string} configuratorId 
         * @param {ProductConfiguratorCreateStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorCreateStep(tenantId: string, configuratorId: string, body: ProductConfiguratorCreateStepRequest, options?: any): AxiosPromise<ProductconfiguratorstepEntity> {
            return localVarFp.productConfiguratorCreateStep(tenantId, configuratorId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a step from a product configurator by specifying the tenant and step IDs. Ensure precision in configuration management with a straightforward DELETE request, simplifying the elimination of unwanted steps.
         * @summary Delete Step
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorDeleteStep(tenantId: string, stepId: string, options?: any): AxiosPromise<GooglerpcStatus> {
            return localVarFp.productConfiguratorDeleteStep(tenantId, stepId, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing step within a product configurator by specifying the tenant and step IDs. Utilize a PUT request with updated step details in the body for seamless customization and fine-tuning of your product configurations.
         * @summary Update Step
         * @param {string} tenantId 
         * @param {string} stepId 
         * @param {ProductConfiguratorUpdateStepRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productConfiguratorUpdateStep(tenantId: string, stepId: string, body: ProductConfiguratorUpdateStepRequest, options?: any): AxiosPromise<ProductconfiguratorstepEntity> {
            return localVarFp.productConfiguratorUpdateStep(tenantId, stepId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StepApi - object-oriented interface
 * @export
 * @class StepApi
 * @extends {BaseAPI}
 */
export class StepApi extends BaseAPI {
    /**
     * Add multiple steps to an existing product configurator simultaneously. Submit a POST request with the necessary step details in the body to efficiently extend the configuration process in bulk. Simplify large-scale configuration management effortlessly.
     * @summary Bulk Create Steps
     * @param {string} tenantId 
     * @param {string} configuratorId 
     * @param {ProductConfiguratorBulkCreateStepsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepApi
     */
    public productConfiguratorBulkCreateSteps(tenantId: string, configuratorId: string, body: ProductConfiguratorBulkCreateStepsRequest, options?: RawAxiosRequestConfig) {
        return StepApiFp(this.configuration).productConfiguratorBulkCreateSteps(tenantId, configuratorId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Efficiently remove multiple steps from a product configurator using a bulk delete operation. Specify the tenant ID and submit a POST request with the list of step IDs in the body for streamlined configuration management.
     * @summary Bulk Delete Steps
     * @param {string} tenantId 
     * @param {ProductConfiguratorBulkDeleteStepsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepApi
     */
    public productConfiguratorBulkDeleteSteps(tenantId: string, body: ProductConfiguratorBulkDeleteStepsRequest, options?: RawAxiosRequestConfig) {
        return StepApiFp(this.configuration).productConfiguratorBulkDeleteSteps(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Duplicate an existing step from the source to a specified tenant. Utilize a POST request with an empty body to initiate the copy process, creating a new step based on the source configuration. Streamline step replication effortlessly.
     * @summary Copy Step
     * @param {string} tenantId 
     * @param {string} sourceStepId 
     * @param {ProductConfiguratorCopyStepRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepApi
     */
    public productConfiguratorCopyStep(tenantId: string, sourceStepId: string, body: ProductConfiguratorCopyStepRequest, options?: RawAxiosRequestConfig) {
        return StepApiFp(this.configuration).productConfiguratorCopyStep(tenantId, sourceStepId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new step to an existing product configurator by specifying the tenant and configurator IDs. Utilize a POST request with the required step details in the body to seamlessly extend the configuration process.
     * @summary Create Step
     * @param {string} tenantId 
     * @param {string} configuratorId 
     * @param {ProductConfiguratorCreateStepRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepApi
     */
    public productConfiguratorCreateStep(tenantId: string, configuratorId: string, body: ProductConfiguratorCreateStepRequest, options?: RawAxiosRequestConfig) {
        return StepApiFp(this.configuration).productConfiguratorCreateStep(tenantId, configuratorId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a step from a product configurator by specifying the tenant and step IDs. Ensure precision in configuration management with a straightforward DELETE request, simplifying the elimination of unwanted steps.
     * @summary Delete Step
     * @param {string} tenantId 
     * @param {string} stepId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepApi
     */
    public productConfiguratorDeleteStep(tenantId: string, stepId: string, options?: RawAxiosRequestConfig) {
        return StepApiFp(this.configuration).productConfiguratorDeleteStep(tenantId, stepId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify an existing step within a product configurator by specifying the tenant and step IDs. Utilize a PUT request with updated step details in the body for seamless customization and fine-tuning of your product configurations.
     * @summary Update Step
     * @param {string} tenantId 
     * @param {string} stepId 
     * @param {ProductConfiguratorUpdateStepRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepApi
     */
    public productConfiguratorUpdateStep(tenantId: string, stepId: string, body: ProductConfiguratorUpdateStepRequest, options?: RawAxiosRequestConfig) {
        return StepApiFp(this.configuration).productConfiguratorUpdateStep(tenantId, stepId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



