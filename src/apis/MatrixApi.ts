/* tslint:disable */
/* eslint-disable */
/**
 * Product Configurator Service
 * ## Introduction  This comprehensive guide will equip you with the knowledge to integrate and leverage our Product Configurator Service in your applications.  ## Quick Start  Get up and running in no time! Follow these steps to kickstart your integration:  1. **Authentication:** Obtain your integration JWT to authenticate your requests. 2. **Client Libraries:** Explore our GitHub repositories to grab client libraries in your preferred programming language. 3. **API Overview:** Familiarize yourself with our RESTful API using the OpenAPI specification.  ## Integration  ### API Overview  Our RESTful API is the gateway to unlocking the full potential of Product Configurator. Check out the detailed [API Reference](/docs/category/configurator) for a granular understanding of each endpoint and request/response format.  ### Client Libraries  To expedite your integration process, we provide client libraries for various programming languages. Find the one that suits your stack in our [GitHub repositories](https://github.com/Gemini-Commerce).  ### Authentication  Security is paramount. Learn how to authenticate your requests using JWT. This ensures a secure and reliable connection between your application and Product Configurator.  ## Configuration Management  ### Configurator Lifecycle  Understand the lifecycle of configurators, from draft to active and deleted. This flexibility allows you to manage configurations at your own pace.  ### Steps and Options  Configure product steps with ease and define options effortlessly. Explore the power of dependencies to create dynamic and intuitive configurations.  ### Matrices  Delve into matricesâ€”your secret weapon. Explore price and weight matrices, and learn how configured steps influence properties and pricing.  ### Price Management  Unleash dynamic pricing with our versatile price matrices. From fixed prices to incremental structures, adapt to diverse pricing models effortlessly.  ## Security  Your data is in safe hands. Discover how Product Configurator ensures security through JWT authentication, safeguarding your sensitive information.  ## Backward Compatibility  Stay ahead of the curve. Learn about our versioning strategy, providing backward compatibility while allowing our service to evolve seamlessly.  ## Developer Support  Have questions? Need assistance? Write to us at [info@gemini-commerce.com](mailto:info@gemini-commerce.com) and we will get back to you.
 *
 * The version of the OpenAPI document: v1
 * Contact: info@gemini-commerce.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GooglerpcStatus,
  MatrixListMatricesResponse,
  ProductConfiguratorCreateMatrixRequest,
  ProductConfiguratorListMatricesRequest,
  ProductConfiguratorUpdateMatrixRequest,
  ProductconfiguratormatrixEntity,
} from '../models/index';
import {
    GooglerpcStatusFromJSON,
    GooglerpcStatusToJSON,
    MatrixListMatricesResponseFromJSON,
    MatrixListMatricesResponseToJSON,
    ProductConfiguratorCreateMatrixRequestFromJSON,
    ProductConfiguratorCreateMatrixRequestToJSON,
    ProductConfiguratorListMatricesRequestFromJSON,
    ProductConfiguratorListMatricesRequestToJSON,
    ProductConfiguratorUpdateMatrixRequestFromJSON,
    ProductConfiguratorUpdateMatrixRequestToJSON,
    ProductconfiguratormatrixEntityFromJSON,
    ProductconfiguratormatrixEntityToJSON,
} from '../models/index';

export interface ProductConfiguratorCreateMatrixOperationRequest {
    tenantId: string;
    body: ProductConfiguratorCreateMatrixRequest;
}

export interface ProductConfiguratorDeleteMatrixRequest {
    tenantId: string;
    matrixId: string;
}

export interface ProductConfiguratorGetMatrixRequest {
    tenantId: string;
    matrixId: string;
}

export interface ProductConfiguratorListMatricesOperationRequest {
    tenantId: string;
    configuratorId: string;
    pageSize: string;
    body: ProductConfiguratorListMatricesRequest;
}

export interface ProductConfiguratorRemovePricelistFromMatrixRequest {
    tenantId: string;
    matrixId: string;
    pricelistGrn: string;
}

export interface ProductConfiguratorUpdateMatrixOperationRequest {
    tenantId: string;
    matrixId: string;
    body: ProductConfiguratorUpdateMatrixRequest;
}

/**
 * 
 */
export class MatrixApi extends runtime.BaseAPI {

    /**
     * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
     * Create Matrix
     */
    async productConfiguratorCreateMatrixRaw(requestParameters: ProductConfiguratorCreateMatrixOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductconfiguratormatrixEntity>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling productConfiguratorCreateMatrix.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling productConfiguratorCreateMatrix.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("standardAuthorization", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // APIAuthorization authentication
        }

        const response = await this.request({
            path: `/v1/{tenantId}/matrix/create`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductConfiguratorCreateMatrixRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductconfiguratormatrixEntityFromJSON(jsonValue));
    }

    /**
     * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
     * Create Matrix
     */
    async productConfiguratorCreateMatrix(requestParameters: ProductConfiguratorCreateMatrixOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductconfiguratormatrixEntity> {
        const response = await this.productConfiguratorCreateMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
     * Delete Matrix
     */
    async productConfiguratorDeleteMatrixRaw(requestParameters: ProductConfiguratorDeleteMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling productConfiguratorDeleteMatrix.');
        }

        if (requestParameters.matrixId === null || requestParameters.matrixId === undefined) {
            throw new runtime.RequiredError('matrixId','Required parameter requestParameters.matrixId was null or undefined when calling productConfiguratorDeleteMatrix.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("standardAuthorization", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // APIAuthorization authentication
        }

        const response = await this.request({
            path: `/v1/{tenantId}/matrix/{matrixId}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"matrixId"}}`, encodeURIComponent(String(requestParameters.matrixId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
     * Delete Matrix
     */
    async productConfiguratorDeleteMatrix(requestParameters: ProductConfiguratorDeleteMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.productConfiguratorDeleteMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
     * Get Matrix
     */
    async productConfiguratorGetMatrixRaw(requestParameters: ProductConfiguratorGetMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductconfiguratormatrixEntity>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling productConfiguratorGetMatrix.');
        }

        if (requestParameters.matrixId === null || requestParameters.matrixId === undefined) {
            throw new runtime.RequiredError('matrixId','Required parameter requestParameters.matrixId was null or undefined when calling productConfiguratorGetMatrix.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("standardAuthorization", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // APIAuthorization authentication
        }

        const response = await this.request({
            path: `/v1/{tenantId}/matrix/{matrixId}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"matrixId"}}`, encodeURIComponent(String(requestParameters.matrixId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductconfiguratormatrixEntityFromJSON(jsonValue));
    }

    /**
     * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
     * Get Matrix
     */
    async productConfiguratorGetMatrix(requestParameters: ProductConfiguratorGetMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductconfiguratormatrixEntity> {
        const response = await this.productConfiguratorGetMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
     * List Matrices
     */
    async productConfiguratorListMatricesRaw(requestParameters: ProductConfiguratorListMatricesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MatrixListMatricesResponse>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling productConfiguratorListMatrices.');
        }

        if (requestParameters.configuratorId === null || requestParameters.configuratorId === undefined) {
            throw new runtime.RequiredError('configuratorId','Required parameter requestParameters.configuratorId was null or undefined when calling productConfiguratorListMatrices.');
        }

        if (requestParameters.pageSize === null || requestParameters.pageSize === undefined) {
            throw new runtime.RequiredError('pageSize','Required parameter requestParameters.pageSize was null or undefined when calling productConfiguratorListMatrices.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling productConfiguratorListMatrices.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("standardAuthorization", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // APIAuthorization authentication
        }

        const response = await this.request({
            path: `/v1/{tenantId}/configurator/{configuratorId}/page-size/{pageSize}/matrices`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"configuratorId"}}`, encodeURIComponent(String(requestParameters.configuratorId))).replace(`{${"pageSize"}}`, encodeURIComponent(String(requestParameters.pageSize))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductConfiguratorListMatricesRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MatrixListMatricesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
     * List Matrices
     */
    async productConfiguratorListMatrices(requestParameters: ProductConfiguratorListMatricesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MatrixListMatricesResponse> {
        const response = await this.productConfiguratorListMatricesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
     * Remove Pricelist from Matrix
     */
    async productConfiguratorRemovePricelistFromMatrixRaw(requestParameters: ProductConfiguratorRemovePricelistFromMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductconfiguratormatrixEntity>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling productConfiguratorRemovePricelistFromMatrix.');
        }

        if (requestParameters.matrixId === null || requestParameters.matrixId === undefined) {
            throw new runtime.RequiredError('matrixId','Required parameter requestParameters.matrixId was null or undefined when calling productConfiguratorRemovePricelistFromMatrix.');
        }

        if (requestParameters.pricelistGrn === null || requestParameters.pricelistGrn === undefined) {
            throw new runtime.RequiredError('pricelistGrn','Required parameter requestParameters.pricelistGrn was null or undefined when calling productConfiguratorRemovePricelistFromMatrix.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("standardAuthorization", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // APIAuthorization authentication
        }

        const response = await this.request({
            path: `/v1/{tenantId}/matrix/{matrixId}/pricelist/{pricelistGrn}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"matrixId"}}`, encodeURIComponent(String(requestParameters.matrixId))).replace(`{${"pricelistGrn"}}`, encodeURIComponent(String(requestParameters.pricelistGrn))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductconfiguratormatrixEntityFromJSON(jsonValue));
    }

    /**
     * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
     * Remove Pricelist from Matrix
     */
    async productConfiguratorRemovePricelistFromMatrix(requestParameters: ProductConfiguratorRemovePricelistFromMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductconfiguratormatrixEntity> {
        const response = await this.productConfiguratorRemovePricelistFromMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
     * Update Matrix
     */
    async productConfiguratorUpdateMatrixRaw(requestParameters: ProductConfiguratorUpdateMatrixOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductconfiguratormatrixEntity>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling productConfiguratorUpdateMatrix.');
        }

        if (requestParameters.matrixId === null || requestParameters.matrixId === undefined) {
            throw new runtime.RequiredError('matrixId','Required parameter requestParameters.matrixId was null or undefined when calling productConfiguratorUpdateMatrix.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling productConfiguratorUpdateMatrix.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("standardAuthorization", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // APIAuthorization authentication
        }

        const response = await this.request({
            path: `/v1/{tenantId}/matrix/{matrixId}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"matrixId"}}`, encodeURIComponent(String(requestParameters.matrixId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProductConfiguratorUpdateMatrixRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductconfiguratormatrixEntityFromJSON(jsonValue));
    }

    /**
     * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
     * Update Matrix
     */
    async productConfiguratorUpdateMatrix(requestParameters: ProductConfiguratorUpdateMatrixOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductconfiguratormatrixEntity> {
        const response = await this.productConfiguratorUpdateMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
